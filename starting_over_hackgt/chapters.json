{
  "chapters": [
    "# Chapter 1: Application Controller\n\nWelcome to the first chapter of our tutorial! In this project, we're building a \"Todo\" application, which helps you keep track of your tasks. Before we dive into the code, let's understand the different parts that make our application work together. Think of it like a team, where each member has a specific job.\n\nHereâ€™s a quick overview of our team members:\n\n*   **TodoStore:** Manages the collection of todo items, including adding, removing, updating, filtering, and persisting them to local storage. It also notifies listeners of changes to its state. It's like a librarian for your tasks, keeping track of all your to-do notes, what's done, what's pending, and saving them for later.\n*   **Application Controller:** The central orchestrator of the application, responsible for initializing the UI, binding user interactions to data store operations, and rendering updates to the view. It's like a stage director, telling the actors (UI elements) what to do and responding to audience (user) actions.\n*   **Todo Item Renderer:** A function responsible for creating and updating the HTML representation of a single todo item. It ensures the UI accurately reflects the item's state (e.g., completed, editing). It's like a blueprint and construction crew for a single brick in a wall, making sure it looks right and has the correct properties.\n*   **UI Event Delegation:** A pattern for efficiently handling user interactions on dynamically rendered elements by attaching a single event listener to a parent element. It then determines the specific child element that triggered the event. It's like a receptionist at a large office building who listens for all incoming calls and then directs them to the correct department or person, rather than each person having their own phone line.\n*   **Local Storage Persistence:** The mechanism used to store the application's data (todo items) in the browser's local storage, ensuring that the data is saved and reloaded even after the browser is closed. It also listens for changes from other browser tabs. It's like a persistent notebook where your tasks are written down and kept safe, even if you close the book, and can be synchronized if you have multiple copies open.\n*   **View Router:** Determines which subset of todo items (all, active, or completed) should be displayed based on the URL hash. It updates the UI's filter selection accordingly. It's like a map that guides you to different sections of a park (all items, active items, completed items) based on the path you choose.\n*   **DOM Helpers:** A collection of utility functions that simplify common DOM manipulation tasks, such as inserting or replacing HTML content within an element. It's like a set of specialized tools (e.g., a hammer, screwdriver) that make working with a building's structure easier and more efficient.\n\n***\n\n## What Problem Does the Application Controller Solve?\n\nImagine you're running a play. You have actors (the different parts of your app's display, like a task list), props (the data, like your actual todo items), and an audience (the user). Who tells the actors what to do? Who makes sure they respond when the audience claps or boos? That's the job of the **Application Controller**.\n\nIn our ToDo app, when you type a new task and press Enter, a lot of things need to happen:\n1.  The app needs to *know* you typed something.\n2.  It needs to *save* that new task.\n3.  It needs to *show* that new task on the screen.\n\nWithout a central \"director,\" each part of your app would have to figure this out on its own, leading to a lot of confusion and tangled code. The **Application Controller** steps in to handle all these coordination tasks.\n\n## The Stage Director of Our App\n\nThe Application Controller is like the conductor of an orchestra or the director of a play. It doesn't play the instruments or act in the play itself, but it makes sure everyone plays their part at the right time and in harmony.\n\nIts main responsibilities are:\n*   **Initialization:** Getting everything set up when the app starts.\n*   **Event Handling:** Listening for what the user does (like typing in a task, clicking \"mark complete\").\n*   **Data Management:** Telling the data storage ([TodoStore](02_todostore.md)) what to do based on user actions.\n*   **UI Updates:** Making sure the screen (the \"View\") always shows the most current information.\n\n## How It Works: Adding a New ToDo\n\nLet's walk through our concrete example: how does the **Application Controller** make it possible to add a new ToDo item?\n\n### 1. Starting the Show: `App.init()`\n\nWhen our application first loads, the **Application Controller** (named `App` in our code) kicks everything off with its `init()` method.\n\n```javascript\n// js/app.js\n// ... (imports and Todos setup) ...\n\nconst App = {\n\t// ... (other parts of App) ...\n\tinit() {\n\t\t// Listen for changes in our data store\n\t\tTodos.addEventListener(\"save\", App.render);\n\n\t\t// Listen for user typing a new todo\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\t// 1. Tell the TodoStore to add the new item\n\t\t\t\tTodos.add({ title: e.target.value.trim() });\n\t\t\t\t// 2. Clear the input field\n\t\t\t\tApp.$.input.value = \"\";\n\t\t\t}\n\t\t});\n\t\t// ... (other initializations and event listeners) ...\n\t\tApp.render(); // Show initial todos\n\t},\n\t// ... (rest of App) ...\n};\n\nApp.init(); // This line starts our app!\n```\nIn this snippet:\n*   `App.init()` is the very first thing called when the app starts. It's like the director shouting \"Action!\"\n*   Inside `init()`, we set up various \"listeners.\" These are like ears, waiting for specific things to happen.\n*   One listener is for `Todos.addEventListener(\"save\", App.render);`. This means: \"Whenever our [TodoStore](02_todostore.md) saves data, run `App.render()` to update the screen.\" This is super important because it ensures our UI is *always* up-to-date.\n*   Another listener is attached to `App.$.input` (which is our input field for new todos). It waits for you to press a key (`keyup`). If you press `Enter` and have typed something, it proceeds to add the todo.\n\n### 2. User Action: Typing a New ToDo\n\nWhen you type \"Buy milk\" into the input box and press `Enter`:\n\n```javascript\n// Inside App.init() in js/app.js\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\tTodos.add({ title: e.target.value.trim() }); // This line is crucial!\n\t\t\t\tApp.$.input.value = \"\";\n\t\t\t}\n\t\t});\n```\n*   The `keyup` event listener detects your `Enter` key press.\n*   It then calls `Todos.add({ title: e.target.value.trim() });`. This is the **Application Controller** telling the [TodoStore](02_todostore.md) (our librarian) to add a new book (a new todo item) with the title \"Buy milk\".\n*   After adding, it clears the input field (`App.$.input.value = \"\";`).\n\n### 3. Updating the Display: `App.render()`\n\nOnce the [TodoStore](02_todostore.md) has saved the new todo, it signals back that data has changed. Because we set up `Todos.addEventListener(\"save\", App.render);` earlier, the `App.render()` method is automatically called.\n\nThe `render()` method is the **Application Controller's** job to repaint the stage. It fetches the latest list of todos and updates the entire display.\n\n```javascript\n// js/app.js\n// ... (App object) ...\n\trender() {\n\t\t// Get all todo items, filtered by what the user wants to see (all, active, completed)\n\t\tconst count = Todos.all().length;\n\n\t\t// Update the list of todo items on the screen\n\t\tApp.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\n\t\t// Show/hide main section, footer, clear button based on todo count\n\t\tApp.$.showMain(count);\n\t\tApp.$.showFooter(count);\n\t\tApp.$.showClear(Todos.hasCompleted());\n\n\t\t// Update other UI elements like the \"items left\" counter\n\t\tApp.$.displayCount(Todos.all(\"active\").length);\n\t},\n// ... (rest of App) ...\n```\n*   `App.render()` is responsible for updating *all* parts of the UI that depend on the list of todos.\n*   `App.$.list.replaceChildren(...)` is where the magic happens: it takes the current list of todos from the [TodoStore](02_todostore.md), creates HTML elements for each, and updates the `<ul>` element in our app. It uses `App.createTodoItem(todo)` which, behind the scenes, relies on our [Todo Item Renderer](04_todo_item_renderer.md) concept.\n*   Other helper functions like `App.$.showMain(count)` or `App.$.displayCount(...)` are called to update things like the visibility of the footer or the \"X items left\" message.\n\n## How it All Connects: Under the Hood\n\nLet's visualize the flow when you add a new todo:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as Application Controller\n    participant Todos as TodoStore\n    participant UI as User Interface\n\n    User->>UI: Types \"Buy milk\" and presses Enter\n    UI->>App: \"keyup\" event detected\n    App->>Todos: add({ title: \"Buy milk\" })\n    Todos->>Todos: Saves new todo internally (and to local storage)\n    Todos->>App: Notifies \"save\" event\n    App->>Todos: all(App.filter) (gets updated list)\n    App->>UI: Calls render() to update the display\n    UI->>User: Displays \"Buy milk\" in the todo list\n```\n\nThis sequence shows how the **Application Controller** acts as the central hub, coordinating the user's action with the data storage and then updating the visual display.\n\n### Diving into the Code (`js/app.js`)\n\nHere's how parts of the `App` object in `js/app.js` specifically handle this flow:\n\n#### Initial Setup (`init` method)\n\nThis is where the `App` (our **Application Controller**) first sets up all the event listeners. It's like the director assigning roles and cue sheets to everyone before the play begins.\n\n```javascript\n// js/app.js\nimport { delegate, getURLHash, insertHTML, replaceHTML } from \"./helpers.js\";\nimport { TodoStore } from \"./store.js\"; // This is our TodoStore!\n\nconst Todos = new TodoStore(\"todo-modern-vanillajs\"); // Create an instance of TodoStore\n\nconst App = {\n\t// Our \"App\" object is the Application Controller\n\t// `$` holds references to important UI elements\n\t$: {\n\t\tinput: document.querySelector('[data-todo=\"new\"]'), // The input field for new todos\n\t\tlist: document.querySelector('[data-todo=\"list\"]'), // The <ul> where todos are displayed\n\t\t// ... (other UI elements) ...\n\t},\n\tinit() {\n\t\t// Tell App to re-render the UI whenever the TodoStore changes\n\t\tTodos.addEventListener(\"save\", App.render);\n\n\t\t// Handle adding new todos when the user types in the input field\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\tTodos.add({ title: e.target.value.trim() }); // Tell TodoStore to add a todo\n\t\t\t\tApp.$.input.value = \"\"; // Clear the input field\n\t\t\t}\n\t\t});\n\t\t// ... (other event listeners for toggle all, clear completed, etc.) ...\n\n\t\tApp.render(); // Call render() initially to show any existing todos\n\t},\n    // ... (rest of App methods) ...\n};\n\nApp.init(); // This line runs when the browser loads js/app.js\n```\n*   `Todos.addEventListener(\"save\", App.render);`: This line is key. It tells the `App` that whenever the `Todos` (our [TodoStore](02_todostore.md)) saves something (a new todo, an updated todo, a deleted todo), the `App.render` function should be called. This ensures our UI always reflects the latest data.\n*   `App.$.input.addEventListener(\"keyup\", ...)`: This attaches a listener to the input field. When a key is released, it checks if it was `Enter` and if there's text. If so, it uses `Todos.add()` to store the new item and then clears the input.\n\n#### Rendering the View (`render` method)\n\nThis method is the heart of how the **Application Controller** updates what you see on the screen.\n\n```javascript\n// js/app.js\n// ... (App object) ...\n\tcreateTodoItem(todo) {\n\t\t// This helper creates the actual HTML <li> element for a single todo.\n\t\t// It's part of the Application Controller but works closely with\n\t\t// the concept of a [Todo Item Renderer](04_todo_item_renderer.md).\n\t\tconst li = document.createElement(\"li\");\n\t\tli.dataset.id = todo.id; // Store the todo's ID on the HTML element\n\t\tif (todo.completed) {\n\t\t\tli.classList.add(\"completed\");\n\t\t}\n\t\t// ... (inserts HTML content for view, toggle, label, destroy button, edit input) ...\n\t\tli.querySelector('[data-todo=\"label\"]').textContent = todo.title;\n\t\tli.querySelector('[data-todo=\"edit\"]').value = todo.title;\n\t\treturn li;\n\t},\n\trender() {\n\t\t// Get how many todos we have in total\n\t\tconst count = Todos.all().length;\n\n\t\t// Update the list section by replacing its children\n\t\tApp.$.list.replaceChildren(\n\t\t\t// Get all todos (filtered by current App.filter) and convert each into an HTML <li>\n\t\t\t...Todos.all(App.filter).map((todo) => App.createTodoItem(todo))\n\t\t);\n\n\t\t// Show/hide the main and footer sections if there are any todos\n\t\tApp.$.showMain(count);\n\t\tApp.$.showFooter(count);\n\n\t\t// Update the count of active items displayed\n\t\tApp.$.displayCount(Todos.all(\"active\").length);\n\t},\n// ... (rest of App methods) ...\n```\n*   `App.createTodoItem(todo)`: This is a helper function inside `App` that takes a `todo` object (like `{ id: '123', title: 'Buy milk', completed: false }`) and turns it into a ready-to-display HTML `<li>` element. This concept is explored further in [Todo Item Renderer](04_todo_item_renderer.md).\n*   `App.$.list.replaceChildren(...)`: This line is powerful! It clears out all existing todo items from the `<ul>` element and then inserts new `<li>` elements, generated by calling `App.createTodoItem()` for *every* todo item currently in the [TodoStore](02_todostore.md) (and filtered by what the user wants to see).\n*   The other `App.$.show...` and `App.$.displayCount` calls simply update other parts of the UI, like showing or hiding the footer, or updating the \"X items left\" message, based on the current state of todos.\n\n## Conclusion\n\nThe **Application Controller** is the central brain of our ToDo app. It handles the initial setup, listens to everything the user does, tells the data storage ([TodoStore](02_todostore.md)) what to save or change, and then makes sure the entire display is updated correctly. It's the director ensuring all parts of the show run smoothly and the audience (you!) always sees the correct and latest information.\n\nNow that we understand how the **Application Controller** orchestrates everything, let's dive into the details of the data itself. How does our app actually store and manage all those todo items? We'll explore this in the next chapter: [TodoStore](02_todostore.md).",
    "# Chapter 2: TodoStore\n\nWelcome back! In our last chapter, we met the [Application Controller](01_application_controller.md), the busy director telling everyone what to do. But what exactly is it directing? It's directing the management of our \"todo\" items â€“ all the tasks we want to keep track of. This is where our next key player comes in: the `TodoStore`.\n\n### What Problem Does the TodoStore Solve?\n\nImagine you have a stack of sticky notes, each with a task written on it. Some are done, some are urgent, some are just ideas. If you want to find all the urgent ones, or throw away the done ones, or add a new one, you'd have to sort through them all yourself. That's a lot of work!\n\nThe `TodoStore` is like your personal, super-organized librarian for these sticky notes. Instead of you rummaging through them, you just tell the librarian what you need, and they handle the details.\n\n**Our main goal in this chapter is to understand how we can add a new todo item and have the `TodoStore` manage it for us.**\n\n### Meet the TodoStore: Your Task Librarian\n\nThe `TodoStore` is a dedicated part of our application that holds **all** your todo items. It's not just a simple list; it's a smart manager that knows how to:\n\n*   **Add** new tasks.\n*   **Remove** tasks you no longer need.\n*   **Update** tasks (like changing their name or marking them as \"done\").\n*   **Filter** tasks (show only active ones, or only completed ones).\n*   **Save** your tasks so they don't disappear when you close your browser.\n*   **Notify** other parts of the app when anything changes, so they can update what you see on the screen.\n\nIt's the central source of truth for all your task data.\n\n### How to Use the TodoStore: Adding a New Task\n\nLet's look at how the [Application Controller](01_application_controller.md) uses the `TodoStore` to add a new task.\n\nIn `app.js`, you'll see this line near the top:\n\n```javascript\nimport { TodoStore } from \"./store.js\"; // Bringing in our librarian!\n\nconst Todos = new TodoStore(\"todo-modern-vanillajs\"); // Creating an instance of our librarian\n```\n\nThis creates a specific `TodoStore` object named `Todos`. Think of `Todos` as our actual librarian, ready to take instructions. The text `\"todo-modern-vanillajs\"` is just a special name for where our tasks will be saved, like the name of a specific shelf in the library.\n\nNow, let's see how `Todos` is asked to add a new task. Remember from [Chapter 1: Application Controller](01_application_controller.md) that the Application Controller listens for when you type a new task and press Enter:\n\n```javascript\n// From js/app.js\nApp.$.input.addEventListener(\"keyup\", (e) => {\n    if (e.key === \"Enter\" && e.target.value.trim()) {\n        Todos.add({ title: e.target.value.trim() }); // Here's where we tell the librarian!\n        App.$.input.value = \"\"; // Clear the input box\n    }\n});\n```\n\nWhen you type something like \"Buy milk\" into the input box and press Enter, this code runs. The important line is `Todos.add({ title: e.target.value.trim() });`.\n\n*   `Todos` is our `TodoStore` librarian.\n*   `.add()` is the instruction we're giving the librarian: \"Please add a new task!\"\n*   `{ title: \"Buy milk\" }` is the \"sticky note\" we're handing to the librarian. It tells them the task's title.\n\nAfter this line runs, the `TodoStore` takes over to actually add \"Buy milk\" to its collection and make sure it's saved.\n\n### Under the Hood: How TodoStore Adds a Task\n\nLet's peek behind the scenes and see what our `TodoStore` librarian (`Todos`) does when it receives the `add()` instruction.\n\n#### Step-by-Step Flow\n\nWhen the `Application Controller` tells the `TodoStore` to `add` a new todo item (like \"Buy milk\"):\n\n1.  The `TodoStore` gets the title (\"Buy milk\").\n2.  It creates a complete \"todo item\" object. This isn't just the title; it also includes `completed: false` (because it's a new task, not yet done) and a unique `id` (like a library catalog number) to identify it later.\n3.  It adds this new, complete todo item object to its internal list of all todo items.\n4.  Crucially, it then saves this entire updated list to the browser's local storage. This is like writing down the new task in a special notebook so it's not lost if you close the browser.\n5.  Finally, it sends out a \"save\" notification. This is how the `TodoStore` tells the [Application Controller](01_application_controller.md) (and anyone else listening) that something has changed and the screen might need to be updated.\n\nHere's a simple diagram to visualize this process:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant AppController as Application Controller\n    participant TodoStore as TodoStore\n    participant BrowserLS as Browser Local Storage\n\n    User->>AppController: Types \"Buy milk\" & presses Enter\n    AppController->>TodoStore: add({ title: \"Buy milk\" })\n    TodoStore->>TodoStore: Creates todo item: { id: \"...\", title: \"Buy milk\", completed: false }\n    TodoStore->>TodoStore: Adds new item to its internal list\n    TodoStore->>BrowserLS: Saves updated list of todos\n    BrowserLS-->>TodoStore: (Data saved successfully)\n    TodoStore-->>AppController: Notifies \"save\" event\n    AppController->>AppController: Re-renders the list on the screen\n```\n\n#### The Code That Makes it Happen (`js/store.js`)\n\nLet's look at the `js/store.js` file, which contains the `TodoStore`'s blueprint.\n\nFirst, the `TodoStore` is set up to be able to send notifications. It does this by extending `EventTarget`:\n\n```javascript\n// From js/store.js\nexport const TodoStore = class extends EventTarget {\n    constructor(localStorageKey) {\n        super(); // This gives our store the ability to send and receive events\n        this.localStorageKey = localStorageKey; // The name for our save file\n        this._readStorage(); // Load any existing todos when the store starts\n        // ... other getter methods for reading todos ...\n    }\n    // ... other methods ...\n};\n```\n\n*   `extends EventTarget`: This is a built-in browser feature that allows objects to \"dispatch\" (send) and \"listen\" for custom events, just like how a button can dispatch a \"click\" event. This is how `TodoStore` tells the [Application Controller](01_application_controller.md) when data changes.\n*   `localStorageKey`: This is the unique name `TodoStore` uses to save its data in the browser's local storage. You'll learn more about this in [Local Storage Persistence](03_local_storage_persistence.md).\n*   `_readStorage()`: This method is called right away to load any existing tasks from local storage when the application starts.\n\nNext, let's examine the `add` method itself:\n\n```javascript\n// From js/store.js\nadd({ title }) {\n    this.todos.push({ // Add the new todo to our internal list\n        title,\n        completed: false, // New tasks are not completed by default\n        id: \"id_\" + Date.now(), // Give it a unique ID\n    });\n    this._save(); // Don't forget to save our changes!\n}\n```\n\n*   `this.todos.push(...)`: `this.todos` is the `TodoStore`'s internal array (list) that holds all the todo items. `push()` adds a new item to the end of this list.\n*   `id: \"id_\" + Date.now()`: This creates a simple, unique ID for each todo item using the current time (`Date.now()`). This ID helps us find and update specific tasks later.\n*   `this._save()`: After adding the new task, we immediately call `_save()` to make sure the change is stored permanently.\n\nAnd finally, the `_save()` method that handles persistence and notification:\n\n```javascript\n// From js/store.js\n_save() {\n    window.localStorage.setItem( // Save the list in the browser's local storage\n        this.localStorageKey,\n        JSON.stringify(this.todos) // Convert our list to a text format\n    );\n    this.dispatchEvent(new CustomEvent(\"save\")); // Tell everyone that we saved!\n}\n```\n\n*   `window.localStorage.setItem(...)`: This is the magic that saves your data in the browser. You'll learn all about this in [Local Storage Persistence](03_local_storage_persistence.md).\n*   `JSON.stringify(this.todos)`: Our list of todos (`this.todos`) is an array of JavaScript objects. Local storage can only store text, so `JSON.stringify` converts our objects into a single string (text) that can be saved.\n*   `this.dispatchEvent(new CustomEvent(\"save\"))`: This is the \"notification\" step! It creates a new custom event named \"save\" and sends it out. The [Application Controller](01_application_controller.md) listens for this event, and when it hears it, it knows to re-render the list of todos on the screen.\n\n### Other Important TodoStore Operations\n\nBeyond `add()`, the `TodoStore` provides many other useful methods to manage your tasks, all following a similar pattern: they change the `this.todos` list and then call `_save()` to persist the changes and notify listeners.\n\n*   `remove({ id })`: Deletes a todo item based on its ID.\n*   `toggle({ id })`: Flips the `completed` status of a todo item (e.g., from not done to done).\n*   `update(todo)`: Changes the details of an existing todo item.\n*   `clearCompleted()`: Removes all todo items that are marked as completed.\n*   `toggleAll()`: Marks all active todos as completed, or all completed todos as active.\n*   `get(id)`: Fetches a single todo item by its ID (doesn't change data).\n*   `all(filter)`: Returns a list of todo items, optionally filtered by their status (all, active, or completed).\n\nThese methods make the `TodoStore` a powerful and easy-to-use manager for all your tasks, abstracting away the complexities of data handling.\n\n### Conclusion\n\nThe `TodoStore` is like the reliable librarian of our application. It's solely responsible for managing our collection of todo items, handling all the adding, removing, updating, and filtering. It also plays a vital role in data persistence by saving our tasks to local storage and informing the rest of the application about any changes.\n\nUnderstanding the `TodoStore` is crucial because it's where all our application's data lives. In the next chapter, we'll dive deeper into how this data is actually saved and loaded, uncovering the secrets of [Local Storage Persistence](03_local_storage_persistence.md).",
    "# Chapter 3: Local Storage Persistence\n\nWelcome back! In our last chapter, we met the [TodoStore](02_todostore.md), our application's helpful librarian who keeps track of all our to-do items. The [TodoStore](02_todostore.md) knows how to add, remove, and update tasks, but there's a big question: what happens to our tasks if we close the browser tab or shut down our computer? Do they just disappear forever?\n\nThat's where **Local Storage Persistence** comes in!\n\n### The Problem: Forgetting Tasks\n\nImagine you're diligently adding your tasks to our to-do app: \"Buy groceries,\" \"Call Mom,\" \"Finish Chapter 3 tutorial.\" You feel productive! But then, you accidentally close your browser. Or maybe your computer restarts. When you open the app again, you'd be pretty upset if all your tasks were gone, right?\n\nWebsites, by default, are a bit forgetful. They usually lose all their information as soon as you close the tab. This is where **Local Storage Persistence** saves the day!\n\n### The Solution: A Persistent Notebook\n\n**Local Storage Persistence** is like a special, persistent notebook that our application keeps inside your browser. This notebook remembers your tasks even after you close the browser and open it again. It makes sure your hard work isn't lost.\n\nIt's also super clever! If you open our to-do app in two different browser tabs at the same time, and you add a task in one tab, this \"notebook\" system will make sure the other tab instantly knows about the new task too. It keeps everything synchronized!\n\n### How Our App Uses This \"Notebook\"\n\nOur [TodoStore](02_todostore.md) (the librarian) works closely with **Local Storage Persistence** (the persistent notebook).\n\nWhen the [TodoStore](02_todostore.md) first starts, it asks the notebook: \"Hey, do you have any tasks saved from before?\"\nWhen you add, remove, or change a task, the [TodoStore](02_todostore.md) tells the notebook: \"Please write down this updated list of tasks!\"\n\nLet's look at how the [TodoStore](02_todostore.md) connects to this notebook.\n\n#### 1. Giving the Notebook a Name\n\nWhen we create our [TodoStore](02_todostore.md), we give it a unique name (a `localStorageKey`). This is like putting a label on our notebook so we don't mix up our to-do list with other websites' saved data.\n\n```javascript\n// From: js/store.js\nexport const TodoStore = class extends EventTarget {\n\tconstructor(localStorageKey) {\n\t\tsuper();\n\t\tthis.localStorageKey = localStorageKey; // This is our notebook's name!\n\t\tthis._readStorage(); // Read tasks from the notebook when we start\n\t\t// ... more code ...\n\t}\n\t// ... more methods ...\n};\n```\n\nHere, `localStorageKey` is just a string, like `\"my-todo-app-tasks\"`. It tells the browser where to find *our specific* list of tasks.\n\n#### 2. Reading Tasks from the Notebook\n\nThe `_readStorage()` method is responsible for opening our persistent notebook and reading all the tasks written inside it.\n\n```javascript\n// From: js/store.js\n\t// ... inside TodoStore class ...\n\t_readStorage() {\n\t\t// 1. Ask the browser's local storage for items using our key\n\t\tconst storedTodos = window.localStorage.getItem(this.localStorageKey);\n\t\t// 2. If there's nothing, start with an empty list.\n\t\t// 3. If there are items, they are text, so convert them back to a list of tasks.\n\t\tthis.todos = JSON.parse(storedTodos || \"[]\");\n\t}\n\t// ... more methods ...\n```\n\n**What's happening here?**\n\n*   `window.localStorage.getItem(this.localStorageKey)`: This is how we ask the browser's local storage for the data associated with our notebook's name. It gives us back a string of text.\n*   `JSON.parse(...)`: Local storage can only store text. Our tasks are objects (with properties like `title`, `completed`, `id`). `JSON.parse()` is like a translator that converts the saved text back into usable JavaScript objects. If there's no data saved yet (`storedTodos` is empty), we just give it `[]` (an empty list) to start with.\n\n#### 3. Writing Tasks to the Notebook\n\nWhen we add, remove, or change a task, our [TodoStore](02_todostore.md) calls the `_save()` method. This method writes the current list of tasks into our persistent notebook.\n\n```javascript\n// From: js/store.js\n\t// ... inside TodoStore class ...\n\t_save() {\n\t\t// 1. Convert our list of tasks (objects) into a single string of text.\n\t\tconst todosAsString = JSON.stringify(this.todos);\n\t\t// 2. Ask the browser's local storage to save this text under our key.\n\t\twindow.localStorage.setItem(this.localStorageKey, todosAsString);\n\t\t// 3. Tell other parts of the app that something was saved.\n\t\tthis.dispatchEvent(new CustomEvent(\"save\"));\n\t}\n\t// ... more methods ...\n```\n\n**What's happening here?**\n\n*   `JSON.stringify(this.todos)`: This is the opposite of `JSON.parse()`. It takes our list of JavaScript task objects and converts them into a single string of text that local storage can understand and save.\n*   `window.localStorage.setItem(this.localStorageKey, todosAsString)`: This tells the browser's local storage to take our `todosAsString` and store it under our notebook's name (`this.localStorageKey`).\n*   `this.dispatchEvent(new CustomEvent(\"save\"))`: After saving, the [TodoStore](02_todostore.md) sends out a small signal (an event) saying, \"Hey, I just saved something!\" Other parts of our app, like the [Application Controller](01_application_controller.md), might listen for this signal to update the display.\n\nYou can see how `_save()` is called whenever tasks are changed:\n\n```javascript\n// From: js/store.js\n\t// ... inside TodoStore class ...\n\tadd({ title }) {\n\t\tthis.todos.push({\n\t\t\ttitle,\n\t\t\tcompleted: false,\n\t\t\tid: \"id_\" + Date.now(),\n\t\t});\n\t\tthis._save(); // <-- Tasks changed, so save them!\n\t}\n\tremove({ id }) {\n\t\tthis.todos = this.todos.filter((todo) => todo.id !== id);\n\t\tthis._save(); // <-- Tasks changed, so save them!\n\t}\n\t// ... many other methods also call _save() ...\n```\n\n### Syncing Across Multiple Tabs\n\nRemember how we said our persistent notebook is super clever and can synchronize between tabs? This is a really neat feature of browser local storage!\n\nWhen data is changed in local storage by one browser tab, the browser automatically tells *all other open tabs* that are using the same `localStorageKey` that something has changed. Our app listens for this notification.\n\n```javascript\n// From: js/store.js\nexport const TodoStore = class extends EventTarget {\n\tconstructor(localStorageKey) {\n\t\tsuper();\n\t\tthis.localStorageKey = localStorageKey;\n\t\tthis._readStorage();\n\t\t// Listen for changes from other browser windows/tabs!\n\t\twindow.addEventListener(\n\t\t\t\"storage\",\n\t\t\t() => {\n\t\t\t\tthis._readStorage(); // Read the latest tasks from the notebook\n\t\t\t\tthis._save(); // Re-save (this also dispatches a 'save' event)\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t\t// ... more code ...\n\t}\n\t// ... more methods ...\n};\n```\n\n**What's happening here?**\n\n*   `window.addEventListener(\"storage\", ...)`: This line sets up a \"listener.\" It's like telling our app, \"Keep an ear out for any 'storage' events!\"\n*   When a `storage` event happens (meaning another tab changed our `localStorageKey` data), our app immediately calls `_readStorage()` to fetch the updated task list. Then it calls `_save()` to make sure its own state is also saved and to trigger the `save` event, notifying the rest of the application (like the UI) to update.\n\nThis ensures that if you have your to-do list open in Chrome and Firefox, or two Chrome tabs, adding a task in one will make it appear in the others almost instantly!\n\nHere's a quick flow of how cross-tab sync works:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant TabA as App Tab A\n    participant BrowserLocalStorage as Browser Local Storage\n    participant TabB as App Tab B\n\n    User->>TabA: Adds \"Buy Milk\"\n    TabA->>BrowserLocalStorage: Saves \"Buy Milk\" list\n    BrowserLocalStorage-->>TabB: Notifies: \"Hey, data for 'my-todo-app-tasks' changed!\"\n    TabB->>TabB: Receives \"storage\" event\n    TabB->>BrowserLocalStorage: Reads updated list (\"Buy Milk\")\n    TabB->>TabB: Updates its own tasks and UI\n```\n\n### Conclusion\n\nYou've learned that **Local Storage Persistence** is our application's memory. It uses the browser's `localStorage` to save our tasks (as text using `JSON.stringify`) so they stick around even after the browser closes. It also cleverly listens for changes from other tabs (`window.addEventListener(\"storage\")`) to keep everything perfectly synchronized.\n\nThanks to this mechanism, our [TodoStore](02_todostore.md) always has the most up-to-date list of tasks, whether they were added moments ago or weeks ago!\n\nNext, we'll dive into how each individual todo item is drawn on the screen, in [Chapter 4: Todo Item Renderer](04_todo_item_renderer.md).",
    "# Chapter 4: Todo Item Renderer\n\nIn the last chapter, we learned about [Local Storage Persistence](03_local_storage_persistence.md), which is how our application keeps your todo list safe even if you close your browser. It's like having a special notebook that remembers everything. But how do these saved todos actually *appear* on your screen? How do we turn plain data like \"Buy milk\" into a visible, clickable item on a web page?\n\nThat's where the **Todo Item Renderer** comes in!\n\n### What Does the Todo Item Renderer Do?\n\nImagine you have a recipe for a cake (this is like your todo item's data: \"Buy milk\", \"completed: false\"). The browser doesn't understand recipes; it needs a real, baked cake to display! The **Todo Item Renderer** is like the chef who follows that recipe (your todo data) and bakes the actual cake (an HTML element) that you can see and interact with on the page.\n\nIts main job is to:\n*   Take a single todo item's information (like its ID, text, and whether it's done).\n*   Turn that information into a piece of HTML code (like a list item `<li>` element).\n*   Make sure this HTML looks correct, reflecting if the item is completed, or if it's currently being edited.\n\nIt's the blueprint and construction crew for each individual task you see on your list.\n\n### Our Goal: Displaying a Single Todo\n\nLet's say our [TodoStore](02_todostore.md) gives us this piece of data for a todo item:\n\n```javascript\n// This is just data, not visible on the screen yet!\nconst myTodoData = {\n    id: \"abc-123\",\n    title: \"Walk the dog\",\n    completed: false\n};\n```\n\nOur goal for the Todo Item Renderer is to turn `myTodoData` into something that looks like this on the webpage:\n\n```html\n<!-- This is what we want to create and show -->\n<li data-id=\"abc-123\">\n    <div class=\"view\">\n        <input class=\"toggle\" type=\"checkbox\">\n        <label>Walk the dog</label>\n        <button class=\"destroy\"></button>\n    </div>\n    <input class=\"edit\">\n</li>\n```\n\nThis HTML `<li>` (list item) has everything we need: a checkbox to mark it done, a label to show the text, a button to delete it, and even a hidden input box for editing.\n\n### How to Use the Todo Item Renderer\n\nIn our application, the `App.createTodoItem()` function acts as our Todo Item Renderer. The [Application Controller](01_application_controller.md) calls this function whenever it needs to show a todo item on the screen.\n\nIt's used like this:\n\n```javascript\n// File: js/app.js (simplified view)\n\n// Imagine 'todo' is our data: { id: \"abc-123\", title: \"Walk the dog\", completed: false }\nconst myHtmlElement = App.createTodoItem(todo);\n\n// After this, 'myHtmlElement' holds the actual <li> HTML element!\n// It's ready to be added to the list on the page.\n```\n\nThe `App.createTodoItem()` function expects a `todo` object (like `myTodoData` above) and returns a fully built HTML `<li>` element.\n\n### Inside the Todo Item Renderer: The \"Construction Crew\" at Work\n\nLet's peek under the hood of `App.createTodoItem()` to see how it builds the HTML.\n\n#### Step-by-Step Walkthrough\n\n1.  **Start with a Blank Slate**: The renderer first creates an empty `<li>` (list item) element, like preparing a new blank piece of paper.\n2.  **Give it an ID**: It then attaches a special `data-id` to this `<li>` that matches the todo item's unique ID. This is like writing the unique serial number on our piece of paper.\n3.  **Check for \"Completed\"**: If the todo item is marked as `completed` (e.g., `completed: true`), the renderer adds a special CSS class (like `completed`) to the `<li>`. This class usually makes the item look different, like showing a strikethrough text.\n4.  **Insert the Standard Parts**: It then inserts the basic \"template\" HTML structure inside the `<li>`. This includes the `div` for viewing, the checkbox, the label, the delete button, and the edit input field. This is like adding the pre-made parts of our cake (the layers, frosting, decorations).\n5.  **Fill in the Specifics**: Finally, it takes the `title` from our todo data (\"Walk the dog\") and puts it into the `<label>` and the edit `<input>` field. This is like adding the specific flavor or topping to our cake.\n6.  **Hand it Over**: The completed `<li>` HTML element is then returned, ready to be displayed.\n\n```mermaid\nsequenceDiagram\n    participant AC as Application Controller\n    participant TIR as Todo Item Renderer\n    participant DOM as Browser's Document Object Model\n\n    AC->>TIR: Call createTodoItem(todoData)\n    TIR->>DOM: Create new <li> element\n    TIR->>DOM: Set data-id, add 'completed' class (if needed)\n    TIR->>DOM: Insert inner HTML structure (checkbox, label, buttons)\n    TIR->>DOM: Fill label text & edit input value from todoData\n    TIR-->>AC: Return fully built <li> element\n```\n\n#### Code Deep Dive\n\nLet's look at the `createTodoItem` function in `js/app.js`.\n\nFirst, it creates a new list item and gives it a unique ID:\n\n```javascript\n// File: js/app.js\n// ... inside the App object ...\n\n\tcreateTodoItem(todo) {\n\t\tconst li = document.createElement(\"li\"); // Create an empty <li> tag\n\t\tli.dataset.id = todo.id;              // Store the todo's unique ID on the <li>\n\t\t// ... more code to build the <li> ...\n\t\treturn li; // Eventually return the complete <li>\n\t},\n```\nHere, `document.createElement(\"li\")` is how JavaScript asks the browser to make a new, blank list item HTML tag. `li.dataset.id = todo.id;` then attaches a special identifier (`data-id`) to this `<li>`, making it easy to find this specific todo item later.\n\nNext, it checks if the todo is completed:\n\n```javascript\n// File: js/app.js\n// ... inside createTodoItem(todo) ...\n\n\t\tif (todo.completed) {\n\t\t\tli.classList.add(\"completed\"); // Add 'completed' class if todo is done\n\t\t}\n\t\t// ... more code ...\n```\nIf `todo.completed` is `true`, it adds the `completed` class to our `<li>`. This class is used by CSS (Cascading Style Sheets) to style the completed tasks differently (like adding a line through them).\n\nThen, it inserts the main HTML structure:\n\n```javascript\n// File: js/app.js\nimport { insertHTML } from \"./helpers.js\"; // Used to easily add HTML content\n\n// ... inside createTodoItem(todo) ...\n\n\t\tinsertHTML(\n\t\t\tli, // Insert this HTML inside our <li> element\n\t\t\t`\n\t\t\t<div class=\"view\">\n\t\t\t\t<input data-todo=\"toggle\" class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\n\t\t\t\t<label data-todo=\"label\"></label>\n\t\t\t\t<button class=\"destroy\" data-todo=\"destroy\"></button>\n\t\t\t</div>\n\t\t\t<input class=\"edit\" data-todo=\"edit\">\n\t\t`\n\t\t);\n\t\t// ... more code ...\n```\nThis is a big step! The `insertHTML` function (which we'll learn more about in [DOM Helpers](05_dom_helpers.md)) is used to place a standard set of HTML elements inside our `<li>`. Notice the `<input type=\"checkbox\">` also checks if `todo.completed` is true and automatically adds `checked` to the checkbox if it is. This ensures the checkbox reflects the todo's state.\n\nFinally, it fills in the specific text and returns the result:\n\n```javascript\n// File: js/app.js\n// ... inside createTodoItem(todo) ...\n\n\t\tli.querySelector('[data-todo=\"label\"]').textContent = todo.title;\n\t\tli.querySelector('[data-todo=\"edit\"]').value = todo.title;\n\t\treturn li; // Hand back the complete HTML <li> element\n\t}, // End of createTodoItem function\n```\nHere, `li.querySelector('[data-todo=\"label\"]')` finds the `<label>` inside our `<li>` and sets its text content to `todo.title` (e.g., \"Walk the dog\"). It does the same for the edit input field. Now, the `<li>` is fully assembled and contains all the necessary data and structure! It's returned to whoever called `createTodoItem`.\n\n#### How `App.render()` Uses It\n\nThe `App.render()` function in our [Application Controller](01_application_controller.md) is responsible for updating the entire list of todos on the screen. It uses `createTodoItem` like this:\n\n```javascript\n// File: js/app.js\n// ... inside App.render() ...\n\n\t\t// Get all todos, then for EACH todo, create an HTML item\n\t\tApp.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\n\t\t// ... more rendering logic ...\n\t},\n```\nThis line is powerful!\n1.  `Todos.all(App.filter)` asks the [TodoStore](02_todostore.md) for all the todo items that should currently be displayed (e.g., all, active, or completed).\n2.  `.map((todo) => App.createTodoItem(todo))` then goes through *each* of those todo items and calls `App.createTodoItem()` on it. This creates a brand new HTML `<li>` element for *every* todo item.\n3.  `App.$.list.replaceChildren(...)` finally takes all these newly created HTML `<li>` elements and puts them into the main todo list (`App.$.list`), replacing any old items that were there before.\n\nThis means that every time something changes in our todo list (a new item is added, one is completed, etc.), the `render()` function rebuilds *all* the visible todo items using our **Todo Item Renderer** to make sure the screen is always up-to-date!\n\n### Conclusion\n\nThe **Todo Item Renderer** is a crucial piece of our application. It acts as the bridge between the plain data stored in our [TodoStore](02_todostore.md) and the visible, interactive HTML elements on our webpage. By taking a `todo` object and transforming it into a properly structured and styled `<li>` element, it ensures that your tasks are always presented accurately.\n\nYou've seen functions like `insertHTML` being used to make this process easier. In the next chapter, we'll dive deeper into these helpful tools, exploring the [DOM Helpers](05_dom_helpers.md) that simplify interacting with and building parts of our web page.\n\n[Next Chapter: DOM Helpers](05_dom_helpers.md)",
    "# Chapter 5: DOM Helpers\n\nWelcome back! In our last chapter, [Todo Item Renderer](04_todo_item_renderer.md), we learned how to create the actual HTML `<li>` structure for a single todo item. It was like designing a blueprint and constructing a single brick for our wall. But how do we actually *put* these newly built bricks into our main todo list wall in the browser? And how do we update existing parts of that wall, like changing a number display?\n\nThis is where **DOM Helpers** come in.\n\n### What Problem Do DOM Helpers Solve?\n\nImagine you're building with LEGOs. You have individual LEGO bricks (your HTML elements), and you want to connect them to build a structure. The \"DOM\" (which stands for Document Object Model) is essentially how your web browser sees and organizes all the HTML elements on a page. Think of it as a big tree structure where every part of your web page (like a paragraph, a button, or an entire list) is a \"node\" or a \"branch.\"\n\nDirectly working with this \"DOM tree\" using plain JavaScript can sometimes feel a bit repetitive or clunky, especially for common tasks like:\n\n1.  **Adding new HTML** into an existing element (e.g., adding a new todo item to our `<ul>` list).\n2.  **Replacing content** inside an element (e.g., updating the \"X items left\" message).\n\nOur **DOM Helpers** are like a small set of specialized tools, such as a mini-crane or a quick-release lever, that make these common tasks much simpler and faster. Instead of writing several lines of code every time, we use a single, friendly helper function.\n\nLet's look at our two main helper tools: `insertHTML` and `replaceHTML`.\n\n### Our Specialized Tools: `insertHTML` and `replaceHTML`\n\nIn our project, we have two key **DOM Helper** functions:\n\n1.  **`insertHTML(element, htmlString)`**: This tool takes an HTML element (where you want to put something) and a string of HTML code (what you want to put there), and then places that HTML *inside* the element, right at the beginning.\n    *   **Analogy**: It's like having a special tool that lets you quickly add a new LEGO piece *inside* another larger LEGO structure, always at the top.\n\n2.  **`replaceHTML(element, htmlString)`**: This tool is a bit more powerful. It first *clears out* everything currently inside an HTML element, and then `insertHTML` to put new HTML content there.\n    *   **Analogy**: This is like using a tool that first empties a LEGO box completely, and then carefully places new LEGO pieces inside.\n\nThese two helpers are found in our `js/helpers.js` file and are imported into our main application logic:\n\n```javascript\n// From js/app.js\nimport { delegate, getURLHash, insertHTML, replaceHTML } from \"./helpers.js\";\n// ... (rest of the file)\n```\n\n### How We Use DOM Helpers\n\nLet's see how our application uses these handy helpers.\n\n#### 1. Adding New Todo Items with `insertHTML`\n\nWhen we create a new todo item (as we saw in [Todo Item Renderer](04_todo_item_renderer.md)), we need to place its HTML structure into the main `<ul>` list where all todos are displayed.\n\nOur `App.createTodoItem` function creates an `<li>` element and then uses `insertHTML` to fill it with the internal `<div>`, `<input>`, and `<button>` elements.\n\n```javascript\n// Simplified excerpt from App.createTodoItem in js/app.js\ncreateTodoItem(todo) {\n    const li = document.createElement(\"li\"); // Create the <li> element\n    // ... (set other properties like li.dataset.id, li.classList)\n\n    insertHTML(\n        li, // The target element: our new <li>\n        `\n        <div class=\"view\">\n            <input data-todo=\"toggle\" class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\n            <label data-todo=\"label\"></label>\n            <button class=\"destroy\" data-todo=\"destroy\"></button>\n        </div>\n        <input class=\"edit\" data-todo=\"edit\">\n        ` // The HTML string to insert inside <li>\n    );\n    // ... (set textContent and value for label/input)\n    return li;\n}\n```\n\n**Explanation**:\nHere, `insertHTML` takes the `li` element we just created and injects the provided HTML string right at the beginning of its content. This quickly builds the internal structure of our todo item without needing to create each `div`, `input`, `label`, and `button` element one by one using `document.createElement`.\n\n#### 2. Updating the Todo Count with `replaceHTML`\n\nAnother common task is updating the text that tells us \"X items left.\" This text often changes as we add, complete, or remove todo items. Instead of carefully finding the old text and changing it, we use `replaceHTML` to simply wipe out the old count and put in the new one.\n\n```javascript\n// Simplified excerpt from App.$.displayCount in js/app.js\ndisplayCount(count) {\n    replaceHTML(\n        document.querySelector('[data-todo=\"count\"]'), // The element showing the count\n        `\n        <strong>${count}</strong>\n        ${count === 1 ? \"item\" : \"items\"} left\n        ` // The new HTML string to display\n    );\n}\n```\n\n**Explanation**:\nIn this example, `replaceHTML` finds the element responsible for showing the todo count (using `document.querySelector('[data-todo=\"count\"]')`). It then completely clears out any HTML that was inside that element and replaces it with our new `<strong>` and text, correctly saying \"1 item left\" or \"2 items left.\"\n\n### Under the Hood: How DOM Helpers Work\n\nLet's peek behind the curtain to see how `insertHTML` and `replaceHTML` actually do their job. They rely on some built-in browser JavaScript features.\n\n#### The `replaceHTML` Flow\n\nWhen `App.$.displayCount` (from our [Application Controller](01_application_controller.md)) calls `replaceHTML`, here's a simplified sequence of events:\n\n```mermaid\nsequenceDiagram\n    participant App as Application Controller\n    participant D_H as DOM Helpers\n    participant Browser as Browser's JavaScript\n\n    App->>D_H: replaceHTML(element, newHTML)\n    D_H->>Browser: element.replaceChildren()\n    Note over Browser: Clears ALL existing content inside 'element'\n    D_H->>D_H: insertHTML(element, newHTML)\n    D_H->>Browser: element.insertAdjacentHTML(\"afterbegin\", newHTML)\n    Note over Browser: Puts newHTML at the beginning of 'element'\n    Browser-->>D_H: HTML updated\n    D_H-->>App: Task finished\n```\n\nAs you can see, `replaceHTML` doesn't do all the work itself. It uses another helper, `insertHTML`, after first clearing the target element.\n\n#### `insertHTML` Implementation\n\nLet's look at the actual code for `insertHTML` from `js/helpers.js`:\n\n```javascript\n// From js/helpers.js\nexport const insertHTML = (el, html) => el.insertAdjacentHTML(\"afterbegin\", html);\n```\n\n**Explanation**:\nThis is a very direct helper! It uses a built-in browser function called `insertAdjacentHTML`. This function is powerful because it lets you inject HTML strings into the DOM at specific positions relative to an element.\n\n*   `el`: This is the HTML element where you want to add content.\n*   `\"afterbegin\"`: This is a special keyword that tells the browser to insert the new `html` string *inside* the `el`, right at the very beginning of its children. Other options exist, but `afterbegin` is what `insertHTML` uses.\n*   `html`: This is the string of HTML code you want to add.\n\nSo, `insertHTML` simply wraps `insertAdjacentHTML(\"afterbegin\", ...)` to provide a cleaner, more readable way to add content to the beginning of an element.\n\n#### `replaceHTML` Implementation\n\nNow for `replaceHTML` from `js/helpers.js`:\n\n```javascript\n// From js/helpers.js\nexport const replaceHTML = (el, html) => {\n    el.replaceChildren(); // Step 1: Clear everything inside 'el'\n    insertHTML(el, html);  // Step 2: Use our 'insertHTML' helper to add new content\n};\n```\n\n**Explanation**:\nThis helper has two steps:\n\n1.  `el.replaceChildren()`: This is another very useful built-in browser function. When you call it on an element, it completely removes *all* of that element's children (anything nested inside it). It's like hitting the \"clear all contents\" button for that part of your web page.\n2.  `insertHTML(el, html)`: After clearing the old content, `replaceHTML` then calls our `insertHTML` helper (which we just looked at) to put the `html` string inside the now-empty `el`.\n\nBy combining these two steps, `replaceHTML` gives us a simple way to completely refresh an element's content.\n\n### Conclusion\n\nIn this chapter, we've explored **DOM Helpers**, a collection of utility functions that act like specialized tools for common DOM manipulation tasks. We learned about `insertHTML` for adding new HTML content and `replaceHTML` for clearing and replacing existing content. These helpers make our code cleaner, easier to understand, and prevent us from writing repetitive DOM operations.\n\nWe saw how they are used by our [Application Controller](01_application_controller.md) and how they simplify the work of placing the HTML created by our [Todo Item Renderer](04_todo_item_renderer.md).\n\nNext up, in [UI Event Delegation](06_ui_event_delegation.md), we'll discover a smart way to handle user interactions like clicks and double-clicks on our todo items, especially when those items are constantly being added and removed!\n\n[Next Chapter: UI Event Delegation](06_ui_event_delegation.md)",
    "# Chapter 6: UI Event Delegation\n\nWelcome back! In our last chapter, [DOM Helpers](05_dom_helpers.md), we learned about handy tools for manipulating parts of our web page. Now, we're going to tackle how our application listens to what you, the user, are doing on those elements â€“ like clicking buttons or typing. This is where **UI Event Delegation** comes in, making our application smarter and more efficient.\n\n### What's the Problem with Lots of Buttons?\n\nImagine our Todo app with a long list of items. Each todo item usually has a \"delete\" button, a checkbox to mark it as complete, and maybe a label you can double-click to edit.\n\nIf we have 100 todo items, that's 100 delete buttons, 100 checkboxes, and 100 labels. A basic way to make them work would be to attach a separate \"click\" listener to *each* and *every* one of these elements.\n\n```javascript\n// A *bad* example for illustration!\n// Don't do this for many items.\nconst deleteButton1 = document.getElementById('delete-todo-1');\ndeleteButton1.addEventListener('click', () => {\n    // Delete todo 1\n});\n\nconst deleteButton2 = document.getElementById('delete-todo-2');\ndeleteButton2.addEventListener('click', () => {\n    // Delete todo 2\n});\n// ... and so on for 100 buttons!\n```\n\nThis approach has a couple of big problems:\n\n1.  **Too many listeners**: Attaching hundreds or even thousands of event listeners can slow down your web page and use a lot of memory. It's like having a separate phone line for every single person in a large office building â€“ very inefficient!\n2.  **New elements**: What happens when you add a *new* todo item to the list? Its delete button won't have a listener, so it won't work! We'd have to remember to add a new listener every time we create a new todo. This is tedious and error-prone.\n\nThis is exactly the problem that **UI Event Delegation** solves!\n\n### The Receptionist Analogy\n\nThink of UI Event Delegation like a **receptionist** in a big office building.\n\n*   Instead of every person in the office having their own phone line (which is like each button having its own event listener), there's **one main receptionist** who answers all incoming calls (this is the *parent element* with one event listener).\n*   When a call comes in, the receptionist asks, \"Who are you trying to reach?\" (this is checking `e.target`).\n*   Then, they **direct the call** to the correct person or department (this is our event handler function that runs specific code based on what was clicked).\n\nSo, in our Todo app, instead of listening to *each individual todo item's button*, we can listen to the **main list** where all todo items live. When something inside the list is clicked, the main list's listener figures out *what* was clicked and *which* todo item it belongs to.\n\n### How We Use Event Delegation in Our App\n\nLet's look at how our `Application Controller` ([Chapter 1](01_application_controller.md)) uses event delegation to handle interactions with todo items. The key magic happens in the `App.bindTodoEvents()` function, which uses a special helper function called `App.todoEvent()`.\n\nFirst, let's see where the `delegate` helper function comes from:\n\n```javascript\n// File: js/app.js (excerpt)\nimport { delegate, /* ...other helpers */ } from \"./helpers.js\";\n// ...\n```\n\nOur `delegate` helper is imported from `js/helpers.js`. It's the core of our event delegation strategy.\n\nNext, the `App.bindTodoEvents()` method sets up all the delegated listeners for our todo list:\n\n```javascript\n// File: js/app.js (excerpt)\n// ...\n\tbindTodoEvents() {\n\t\tApp.todoEvent(\"click\", '[data-todo=\"destroy\"]', (todo) => Todos.remove(todo));\n\t\tApp.todoEvent(\"click\", '[data-todo=\"toggle\"]', (todo) => Todos.toggle(todo));\n\t\tApp.todoEvent(\"dblclick\", '[data-todo=\"label\"]', (_, $li) => {\n\t\t\t$li.classList.add(\"editing\");\n\t\t\t$li.querySelector('[data-todo=\"edit\"]').focus();\n\t\t});\n\t\t// ... more todo events\n\t},\n// ...\n```\n\nNotice how `App.bindTodoEvents` calls `App.todoEvent` multiple times. Each call tells our app to listen for a specific action (like \"click\" or \"dblclick\") on specific kinds of elements (like `[data-todo=\"destroy\"]` buttons or `[data-todo=\"label\"]` elements) *inside* our main todo list.\n\nLet's break down `App.todoEvent()`:\n\n```javascript\n// File: js/app.js (excerpt)\n// ...\n\ttodoEvent(event, selector, handler) {\n\t\tdelegate(App.$.list, selector, event, (e) => {\n\t\t\tlet $el = e.target.closest(\"[data-id]\");\n\t\t\thandler(Todos.get($el.dataset.id), $el, e);\n\t\t});\n\t},\n// ...\n```\n\nThis `todoEvent` method is a special wrapper that makes it easier to use the `delegate` helper.\n\nHere's what each part does:\n\n*   `App.$.list`: This is the big **parent element** (our \"receptionist\"). It's the `<ul>` element that holds all our individual `<li>` todo items. We want to attach *one* listener to this element.\n*   `selector`: This is like saying, \"I'm interested in calls for the 'Delete Button Department' (`[data-todo=\"destroy\"]`) or the 'Edit Label Department' (`[data-todo=\"label\"]`).\" It's a CSS selector that matches the *child elements* we care about.\n*   `event`: This is the type of user interaction, like a `\"click\"`, `\"dblclick\"`, or `\"keyup\"`.\n*   `handler`: This is the function that runs when the specific `event` happens on a matching `selector` *inside* the `App.$.list`.\n    *   Inside this handler, `e.target.closest(\"[data-id]\")` helps us find the actual `<li>` element (the specific todo item) that the clicked element belongs to.\n    *   Then, `Todos.get($el.dataset.id)` fetches the correct todo item data from our `TodoStore` ([Chapter 2](02_todostore.md)).\n    *   Finally, the provided `handler` function (like `(todo) => Todos.remove(todo)`) is called with the relevant `todo` item and the HTML element `$el`.\n\nSo, for example, the line:\n\n```javascript\n// Inside App.bindTodoEvents()\nApp.todoEvent(\"click\", '[data-todo=\"destroy\"]', (todo) => Todos.remove(todo));\n```\n\nMeans: \"Attach *one* 'click' listener to the main `App.$.list`. If any click happens *inside* that list, and the clicked element (or one of its parents) matches `[data-todo=\"destroy\"]`, then find the corresponding todo item and tell the `TodoStore` to `remove` it.\"\n\nThis single line effectively handles clicks for *all* delete buttons, even ones that are added to the list later!\n\n### How the `delegate` Helper Works Under the Hood\n\nLet's peek into `js/helpers.js` to see the `delegate` function itself. It's quite simple but powerful!\n\n```javascript\n// File: js/helpers.js (excerpt)\n// ...\nexport const delegate = (el, selector, event, handler) => {\n\tel.addEventListener(event, (e) => {\n\t\tif (e.target.matches(selector)) handler(e, el);\n\t});\n};\n// ...\n```\n\nHere's a step-by-step breakdown of what happens when you click a \"destroy\" button in our todo list:\n\n1.  **Click happens**: You click on a `<button class=\"destroy\" data-todo=\"destroy\"></button>` within a `<li>` in our `App.$.list` (the `<ul>`).\n2.  **Event Bubbling**: The click event starts at the `button` you clicked. Then, it \"bubbles up\" (travels upwards) through its parent elements: first to the `div`, then to the `li`, and eventually to the `App.$.list` (the `ul`).\n3.  **`delegate`'s Listener Catches It**: Because we attached a single `addEventListener` to `App.$.list` using `delegate`, this listener catches *all* click events that bubble up from inside the list.\n4.  **Is it the right element?**: Inside the `delegate` function, `e.target` refers to the *exact element* that was clicked (in our example, the `<button>`).\n    *   The line `if (e.target.matches(selector))` checks if this clicked element (`e.target`) matches the `selector` we passed in (which was `[data-todo=\"destroy\"]`).\n    *   Since you clicked the destroy button, `e.target` *does* match `[data-todo=\"destroy\"]`.\n5.  **Run the `handler`**: Because it matched, our `handler` function (the `(e) => { ... }` function inside `App.todoEvent`) is now executed. This handler then figures out which todo item to remove from the `TodoStore`.\n\nHere's a simplified sequence of events using a Mermaid diagram:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant DeleteButton as Delete Button Element\n    participant TodoItem as Todo Item (LI)\n    participant TodoList as Todo List (UL)\n    participant DelegateHelper as 'delegate' helper\n    participant TodoEventWrapper as 'App.todoEvent' wrapper\n    participant AppController as Application Controller (Todos.remove)\n\n    User->>DeleteButton: Clicks\n    DeleteButton->>TodoItem: Event bubbles up\n    TodoItem->>TodoList: Event bubbles up\n    TodoList->>DelegateHelper: 'delegate' listener fires\n    DelegateHelper->>TodoEventWrapper: Calls internal handler (e.target.matches('[data-todo=\"destroy\"]'))\n    TodoEventWrapper->>AppController: Identifies todo, calls Todos.remove(todo)\n    AppController-->>User: Todo is removed from UI\n```\n\nThis pattern is incredibly useful because it centralizes all event handling for dynamic lists, making your code cleaner and more performant.\n\n### Benefits of UI Event Delegation\n\n*   **Performance**: Only one listener is needed for a whole container, not for each individual item, saving memory and processing power.\n*   **Dynamic Elements**: When new todo items are added to the list (like when you type a new todo), you don't need to manually attach new event listeners to their buttons. The single delegated listener on the parent automatically handles events for them because events from new children will also bubble up.\n*   **Cleaner Code**: Your `Application Controller` ([Chapter 1](01_application_controller.md)) can declare all its event handling logic in one place, making it easier to understand and maintain.\n\n### Conclusion\n\nYou've now mastered UI Event Delegation! We learned that instead of attaching many event listeners to individual elements, we can attach just one listener to a parent element and let it \"delegate\" handling events for its children. This is a crucial technique for building dynamic, efficient web applications.\n\nNext up, we'll look at how our app manages different views of our todos (all, active, completed) using the [View Router](07_view_router.md).",
    "# Chapter 7: View Router\n\nWelcome back! In our [previous chapter on UI Event Delegation](06_ui_event_delegation.md), we learned how to efficiently manage user interactions across many elements in our To-Do list. Now, imagine you have a very long list of tasks. Sometimes you want to see *all* your tasks, sometimes just the *active* ones (those you haven't finished yet), and other times only the *completed* tasks. How can our application let users switch between these different views? This is exactly the problem our **View Router** helps us solve!\n\nThink of the `View Router` like a helpful guide in a big park. The park has different sections: \"All Tasks,\" \"Active Tasks,\" and \"Completed Tasks.\" When you tell your guide which section you want to visit, they take you there and make sure the map shows your current location.\n\n## The Problem: Filtering What You See\n\nCurrently, our To-Do application shows all tasks. But a good To-Do app usually has filter buttons like \"All,\" \"Active,\" and \"Completed.\"\n\nFor example, if a user clicks the \"Active\" button, we want:\n1.  Only to show tasks that are *not* yet completed.\n2.  The \"Active\" button itself to look \"selected\" (e.g., highlighted) so the user knows what they're viewing.\n3.  If the user refreshes the page or shares the link, it should *still* show \"Active\" tasks.\n\nHow can we achieve this without constantly reloading the entire page? This is where the URL hash comes in.\n\n## What is a URL Hash?\n\nYou've probably seen URLs like `https://example.com/page.html#section2`. The part after the `#` symbol is called the \"URL hash\" (or sometimes \"fragment identifier\"). It's traditionally used to jump to a specific part of a web page.\n\nIn modern web applications, we can cleverly use the URL hash to represent the *state* of our application, like which filter is currently active. For our To-Do app:\n*   `#/` (or nothing after `#`) could mean \"All\" tasks.\n*   `#/active` could mean \"Active\" tasks.\n*   `#/completed` could mean \"Completed\" tasks.\n\nWhen you click on filter links like `All`, `Active`, or `Completed` in our app, the URL in your browser's address bar changes (e.g., from `your-app.com` to `your-app.com/#/active`), but the page doesn't reload! This is a perfect way to let users switch views without interrupting their experience.\n\n## How the View Router Works: A Simple Guide\n\nOur `View Router` does a few key things:\n\n1.  **Reads the Map (URL Hash):** It looks at the URL hash to figure out which section of the \"park\" (which filter) the user wants to see.\n2.  **Updates the Internal State:** It remembers this choice in a special variable (`App.filter`).\n3.  **Shows the Right View:** It tells the [TodoStore](02_todostore.md) to provide only the tasks that match the chosen filter (e.g., only active tasks).\n4.  **Highlights the Path:** It visually updates the filter buttons (e.g., \"Active\") to show which one is currently selected.\n5.  **Listens for Changes:** It constantly listens for when the user clicks a different filter button or manually changes the URL hash. When this happens, it repeats steps 1-4.\n\nLet's see this in action.\n\n## Solving the Filter Use Case with Code\n\nFirst, we need a way to easily get the current URL hash.\n\n### 1. Getting the Current Filter from the URL\n\nWe have a small helper function in `js/helpers.js` called `getURLHash` that extracts the filter name from the URL hash.\n\n```javascript\n// From: js/helpers.js\n\nexport const getURLHash = () => document.location.hash.replace(/^#\\//, \"\");\n```\n\n**Explanation:**\n*   `document.location.hash` gives us the part of the URL starting with `#` (e.g., `#/active`).\n*   `.replace(/^#//, \"\")` is a neat trick to remove the `#/` part, leaving just `active` (or `completed`, or an empty string for `all`).\n\nWhen you call `getURLHash()`, it will return:\n*   `\"\"` (empty string) if the URL is `http://localhost:8080/#/` (which we treat as \"all\").\n*   `\"active\"` if the URL is `http://localhost:8080/#/active`.\n*   `\"completed\"` if the URL is `http://localhost:8080/#/completed`.\n\nThis returned value is stored in `App.filter` in our main [Application Controller](01_application_controller.md).\n\n### 2. Listening for Filter Changes\n\nIn our [Application Controller](01_application_controller.md)'s `init()` method, we first set the initial filter when the app loads, and then we tell the browser to let us know if the URL hash ever changes.\n\n```javascript\n// From: js/app.js (inside App.init())\n\nApp.filter = getURLHash(); // 1. Get initial filter on page load\n\nwindow.addEventListener(\"hashchange\", () => {\n    App.filter = getURLHash(); // 2. Get new filter when URL hash changes\n    App.render();              // 3. Re-render the view to show filtered tasks\n});\n```\n\n**Explanation:**\n*   `App.filter = getURLHash();` sets our initial filter. So, if someone opens the app at `http://localhost:8080/#/active`, `App.filter` will immediately become `\"active\"`.\n*   `window.addEventListener(\"hashchange\", ...)` is super important! The browser fires a `hashchange` event whenever the URL hash changes (e.g., if you click a filter button that updates the hash).\n*   Inside this event listener, we again call `getURLHash()` to update `App.filter` with the *new* hash value.\n*   Then, we call `App.render()`. This tells our application to redraw everything, taking the new filter into account.\n\n### 3. Applying the Filter and Updating UI\n\nThe magic truly happens in our `App.render()` function, which is responsible for drawing our To-Do list.\n\n```javascript\n// From: js/app.js (inside App.render())\n\nrender() {\n    // ... other rendering logic ...\n\n    // 1. Highlight the correct filter link (All, Active, Completed)\n    App.$.setActiveFilter(App.filter);\n\n    // 2. Filter todos from the TodoStore and display them\n    App.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\n    // ... other rendering logic ...\n\n    // 3. Display the count of *active* items\n    App.$.displayCount(Todos.all(\"active\").length);\n}\n```\n\n**Explanation:**\n1.  `App.$.setActiveFilter(App.filter);` uses the current `App.filter` (e.g., `\"active\"`) to add a \"selected\" CSS class to the corresponding filter link in the UI. This visually highlights the active filter.\n2.  `Todos.all(App.filter)` is where the [TodoStore](02_todostore.md) does its job! Instead of just giving us *all* todos, we pass `App.filter` to it. The [TodoStore](02_todostore.md) then intelligently returns only the todos that match the filter (e.g., only \"active\" ones).\n3.  The result of `Todos.all(App.filter)` is then used to create and display the actual To-Do items on the screen.\n4.  Notice that `App.$.displayCount(Todos.all(\"active\").length);` *always* shows the count of `active` items, regardless of the current view, which is a common pattern in To-Do apps.\n\n### How `setActiveFilter` Works\n\nLet's quickly look at `App.$.setActiveFilter` which highlights the filter buttons:\n\n```javascript\n// From: js/app.js (inside App.$)\n\nsetActiveFilter(filter) {\n    document.querySelectorAll(`[data-todo=\"filters\"] a`).forEach((el) => {\n        if (el.matches(`[href=\"#/${filter}\"]`)) { // Check if link's href matches current filter\n            el.classList.add(\"selected\");\n        } else {\n            el.classList.remove(\"selected\");\n        }\n    });\n},\n```\n\n**Explanation:**\n*   It finds all `<a>` tags inside the filters section.\n*   For each link, it checks if its `href` attribute (e.g., `href=\"#/active\"`) matches the current `filter` (e.g., `active`).\n*   If it matches, it adds the `selected` class to highlight it.\n*   If it doesn't match, it removes the `selected` class to un-highlight it.\n\n## View Router in Action: A Step-by-Step Flow\n\nLet's visualize what happens when a user clicks the \"Active\" filter button:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Browser as Web Browser\n    participant AppCtrl as Application Controller\n    participant Helpers as DOM Helpers\n    participant TodoStore as TodoStore\n\n    User->Browser: Clicks \"Active\" filter link (e.g., <a href=\"#/active\">)\n    Browser->Browser: Updates URL hash to #/active\n    Browser->AppCtrl: Triggers 'hashchange' event (on window)\n    AppCtrl->AppCtrl: Event listener calls `getURLHash()`\n    AppCtrl->Helpers: Calls `getURLHash()`\n    Helpers-->AppCtrl: Returns \"active\" (from #/active)\n    AppCtrl->AppCtrl: Sets `App.filter = \"active\"`\n    AppCtrl->AppCtrl: Calls `App.render()`\n    AppCtrl->AppCtrl: Calls `App.$.setActiveFilter(\"active\")`\n    AppCtrl->AppCtrl: Highlights \"Active\" link in UI\n    AppCtrl->TodoStore: Calls `Todos.all(\"active\")`\n    TodoStore-->AppCtrl: Returns list of only active todo items\n    AppCtrl->AppCtrl: `createTodoItem()` for each active todo\n    AppCtrl->Browser: Updates the displayed list of todos (only active ones)\n```\n\nAs you can see, the `View Router` (represented by the `App.filter` and the `hashchange` listener within the [Application Controller](01_application_controller.md) and the `getURLHash` [DOM Helpers](05_dom_helpers.md)) acts as the glue that connects the URL state to what the user sees on the screen.\n\n## Conclusion\n\nThe `View Router` is a powerful concept that allows our application to display different subsets of data based on the URL hash. It makes our app feel more like a real website, where you can bookmark specific views or share links that lead to a filtered list of tasks. By combining `getURLHash` with the `hashchange` event and wisely using `App.filter` in our `App.render()` method, we can create a dynamic and user-friendly filtering experience."
  ]
}