{
  "owner": "1Marc",
  "repo": "modern-todomvc-vanillajs",
  "branch": "main",
  "structure": [
    {
      "name": ".editorconfig",
      "path": ".editorconfig",
      "type": "file",
      "size": 221,
      "content": "root = true\n\n[*]\nindent_style = tab\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[package.json]\nindent_style = tab\nindent_size = 4\n\n[*.md]\ntrim_trailing_whitespace = false\n",
      "encoding": "base64"
    },
    {
      "name": ".gitattributes",
      "path": ".gitattributes",
      "type": "file",
      "size": 12,
      "content": "* text=auto\n",
      "encoding": "base64"
    },
    {
      "name": ".gitignore",
      "path": ".gitignore",
      "type": "file",
      "size": 22,
      "content": "node_modules\n.DS_Store",
      "encoding": "base64"
    },
    {
      "name": ".prettierrc",
      "path": ".prettierrc",
      "type": "file",
      "size": 48,
      "content": "{\n\t\"bracketSpacing\": true,\n\t\"printWidth\": 100\n}\n",
      "encoding": "base64"
    },
    {
      "name": "app-readme.md",
      "path": "app-readme.md",
      "type": "file",
      "size": 675,
      "content": "# Framework Name • [TodoMVC](http://todomvc.com)\n\n> Official description of the framework (from its website)\n\n\n## Resources\n\n- [Website]()\n- [Documentation]()\n- [Used by]()\n- [Blog]()\n- [FAQ]()\n\n### Articles\n\n- [Interesting article]()\n\n### Support\n\n- [Stack Overflow](http://stackoverflow.com/questions/tagged/__)\n- [Google Groups]()\n- [Twitter](http://twitter.com/__)\n- [Google+]()\n\n*Let us [know](https://github.com/tastejs/todomvc/issues) if you discover anything worth sharing.*\n\n\n## Implementation\n\nHow was the app created? Anything worth sharing about the process of creating the app? Any spec violations?\n\n\n## Credit\n\nCreated by [Your Name](http://your-website.com)\n",
      "encoding": "base64"
    },
    {
      "name": "css",
      "path": "css",
      "type": "dir",
      "size": 0,
      "children": [
        {
          "name": "index.css",
          "path": "css/index.css",
          "type": "file",
          "size": 7285,
          "content": "/* Copied from TodoMVC boilerplate CSS to deploy on github pages */\n\n@charset \"utf-8\";\n\nhtml,\nbody {\n\tmargin: 0;\n\tpadding: 0;\n}\n\nbutton {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: none;\n\tfont-size: 100%;\n\tvertical-align: baseline;\n\tfont-family: inherit;\n\tfont-weight: inherit;\n\tcolor: inherit;\n\t-webkit-appearance: none;\n\tappearance: none;\n\t-webkit-font-smoothing: antialiased;\n\t-moz-osx-font-smoothing: grayscale;\n}\n\nbody {\n\tfont: 14px \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\tline-height: 1.4em;\n\tbackground: #f5f5f5;\n\tcolor: #111111;\n\tmin-width: 230px;\n\tmax-width: 550px;\n\tmargin: 0 auto;\n\t-webkit-font-smoothing: antialiased;\n\t-moz-osx-font-smoothing: grayscale;\n\tfont-weight: 300;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\n.todoapp {\n\tbackground: #fff;\n\tmargin: 130px 0 40px 0;\n\tposition: relative;\n\tbox-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2), 0 25px 50px 0 rgba(0, 0, 0, 0.1);\n}\n\n.todoapp input::-webkit-input-placeholder {\n\tfont-style: italic;\n\tfont-weight: 400;\n\tcolor: rgba(0, 0, 0, 0.4);\n}\n\n.todoapp input::-moz-placeholder {\n\tfont-style: italic;\n\tfont-weight: 400;\n\tcolor: rgba(0, 0, 0, 0.4);\n}\n\n.todoapp input::input-placeholder {\n\tfont-style: italic;\n\tfont-weight: 400;\n\tcolor: rgba(0, 0, 0, 0.4);\n}\n\n.todoapp h1 {\n\tposition: absolute;\n\ttop: -140px;\n\twidth: 100%;\n\tfont-size: 80px;\n\tfont-weight: 200;\n\ttext-align: center;\n\tcolor: #b83f45;\n\t-webkit-text-rendering: optimizeLegibility;\n\t-moz-text-rendering: optimizeLegibility;\n\ttext-rendering: optimizeLegibility;\n}\n\n.new-todo,\n.edit {\n\tposition: relative;\n\tmargin: 0;\n\twidth: 100%;\n\tfont-size: 24px;\n\tfont-family: inherit;\n\tfont-weight: inherit;\n\tline-height: 1.4em;\n\tcolor: inherit;\n\tpadding: 6px;\n\tborder: 1px solid #999;\n\tbox-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);\n\tbox-sizing: border-box;\n\t-webkit-font-smoothing: antialiased;\n\t-moz-osx-font-smoothing: grayscale;\n}\n\n.new-todo {\n\tpadding: 16px 16px 16px 60px;\n\theight: 65px;\n\tborder: none;\n\tbackground: rgba(0, 0, 0, 0.003);\n\tbox-shadow: inset 0 -2px 1px rgba(0, 0, 0, 0.03);\n}\n\n.main {\n\tposition: relative;\n\tz-index: 2;\n\tborder-top: 1px solid #e6e6e6;\n}\n\n.toggle-all {\n\twidth: 1px;\n\theight: 1px;\n\tborder: none; /* Mobile Safari */\n\topacity: 0;\n\tposition: absolute;\n\tright: 100%;\n\tbottom: 100%;\n}\n\n.toggle-all + label {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\twidth: 45px;\n\theight: 65px;\n\tfont-size: 0;\n\tposition: absolute;\n\ttop: -65px;\n\tleft: -0;\n}\n\n.toggle-all + label:before {\n\tcontent: \"❯\";\n\tdisplay: inline-block;\n\tfont-size: 22px;\n\tcolor: #949494;\n\tpadding: 10px 27px 10px 27px;\n\t-webkit-transform: rotate(90deg);\n\ttransform: rotate(90deg);\n}\n\n.toggle-all:checked + label:before {\n\tcolor: #484848;\n}\n\n.todo-list {\n\tmargin: 0;\n\tpadding: 0;\n\tlist-style: none;\n}\n\n.todo-list li {\n\tposition: relative;\n\tfont-size: 24px;\n\tborder-bottom: 1px solid #ededed;\n}\n\n.todo-list li:last-child {\n\tborder-bottom: none;\n}\n\n.todo-list li.editing {\n\tborder-bottom: none;\n\tpadding: 0;\n}\n\n.todo-list li.editing .edit {\n\tdisplay: block;\n\twidth: calc(100% - 43px);\n\tpadding: 12px 16px;\n\tmargin: 0 0 0 43px;\n}\n\n.todo-list li.editing .view {\n\tdisplay: none;\n}\n\n.todo-list li .toggle {\n\ttext-align: center;\n\twidth: 40px;\n\t/* auto, since non-WebKit browsers doesn't support input styling */\n\theight: auto;\n\tposition: absolute;\n\ttop: 0;\n\tbottom: 0;\n\tmargin: auto 0;\n\tborder: none; /* Mobile Safari */\n\t-webkit-appearance: none;\n\tappearance: none;\n}\n\n.todo-list li .toggle {\n\topacity: 0;\n}\n\n.todo-list li .toggle + label {\n\t/*\n\t\tFirefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433\n\t\tIE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/\n\t*/\n\tbackground-image: url(\"data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23949494%22%20stroke-width%3D%223%22/%3E%3C/svg%3E\");\n\tbackground-repeat: no-repeat;\n\tbackground-position: center left;\n}\n\n.todo-list li .toggle:checked + label {\n\tbackground-image: url(\"data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%2359A193%22%20stroke-width%3D%223%22%2F%3E%3Cpath%20fill%3D%22%233EA390%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22%2F%3E%3C%2Fsvg%3E\");\n}\n\n.todo-list li label {\n\tword-break: break-all;\n\tpadding: 15px 15px 15px 60px;\n\tdisplay: block;\n\tline-height: 1.2;\n\ttransition: color 0.4s;\n\tfont-weight: 400;\n\tcolor: #484848;\n}\n\n.todo-list li.completed label {\n\tcolor: #949494;\n\ttext-decoration: line-through;\n}\n\n.todo-list li .destroy {\n\tdisplay: none;\n\tposition: absolute;\n\ttop: 0;\n\tright: 10px;\n\tbottom: 0;\n\twidth: 40px;\n\theight: 40px;\n\tmargin: auto 0;\n\tfont-size: 30px;\n\tcolor: #949494;\n\ttransition: color 0.2s ease-out;\n}\n\n.todo-list li .destroy:hover,\n.todo-list li .destroy:focus {\n\tcolor: #c18585;\n}\n\n.todo-list li .destroy:after {\n\tcontent: \"×\";\n\tdisplay: block;\n\theight: 100%;\n\tline-height: 1.1;\n}\n\n.todo-list li:hover .destroy {\n\tdisplay: block;\n}\n\n.todo-list li .edit {\n\tdisplay: none;\n}\n\n.todo-list li.editing:last-child {\n\tmargin-bottom: -1px;\n}\n\n.footer {\n\tpadding: 10px 15px;\n\theight: 20px;\n\ttext-align: center;\n\tfont-size: 15px;\n\tborder-top: 1px solid #e6e6e6;\n}\n\n.footer:before {\n\tcontent: \"\";\n\tposition: absolute;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\theight: 50px;\n\toverflow: hidden;\n\tbox-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), 0 8px 0 -3px #f6f6f6,\n\t\t0 9px 1px -3px rgba(0, 0, 0, 0.2), 0 16px 0 -6px #f6f6f6,\n\t\t0 17px 2px -6px rgba(0, 0, 0, 0.2);\n}\n\n.todo-count {\n\tfloat: left;\n\ttext-align: left;\n}\n\n.todo-count strong {\n\tfont-weight: 300;\n}\n\n.filters {\n\tmargin: 0;\n\tpadding: 0;\n\tlist-style: none;\n\tposition: absolute;\n\tright: 0;\n\tleft: 0;\n}\n\n.filters li {\n\tdisplay: inline;\n}\n\n.filters li a {\n\tcolor: inherit;\n\tmargin: 3px;\n\tpadding: 3px 7px;\n\ttext-decoration: none;\n\tborder: 1px solid transparent;\n\tborder-radius: 3px;\n}\n\n.filters li a:hover {\n\tborder-color: #db7676;\n}\n\n.filters li a.selected {\n\tborder-color: #ce4646;\n}\n\n.clear-completed,\nhtml .clear-completed:active {\n\tfloat: right;\n\tposition: relative;\n\tline-height: 19px;\n\ttext-decoration: none;\n\tcursor: pointer;\n}\n\n.clear-completed:hover {\n\ttext-decoration: underline;\n}\n\n.info {\n\tmargin: 65px auto 0;\n\tcolor: #4d4d4d;\n\tfont-size: 11px;\n\ttext-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);\n\ttext-align: center;\n}\n\n.info p {\n\tline-height: 1;\n}\n\n.info a {\n\tcolor: inherit;\n\ttext-decoration: none;\n\tfont-weight: 400;\n}\n\n.info a:hover {\n\ttext-decoration: underline;\n}\n\n/*\n\tHack to remove background from Mobile Safari.\n\tCan't use it globally since it destroys checkboxes in Firefox\n*/\n@media screen and (-webkit-min-device-pixel-ratio: 0) {\n\t.toggle-all,\n\t.todo-list li .toggle {\n\t\tbackground: none;\n\t}\n\n\t.todo-list li .toggle {\n\t\theight: 40px;\n\t}\n}\n\n@media (max-width: 430px) {\n\t.footer {\n\t\theight: 50px;\n\t}\n\n\t.filters {\n\t\tbottom: 10px;\n\t}\n}\n\n:focus,\n.toggle:focus + label,\n.toggle-all:focus + label {\n\tbox-shadow: 0 0 2px 2px #cf7d7d;\n\toutline: 0;\n}\n",
          "encoding": "base64"
        }
      ]
    },
    {
      "name": "index.html",
      "path": "index.html",
      "type": "file",
      "size": 2003,
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t\t<title>Template • TodoMVC</title>\n\t\t<!-- TodoMVC Boilerplate CSS files -->\n\t\t<link rel=\"stylesheet\" href=\"css/index.css\" />\n\t</head>\n\t<body>\n\t\t<section class=\"todoapp\">\n\t\t\t<header class=\"header\">\n\t\t\t\t<h1>todos</h1>\n\t\t\t\t<input\n\t\t\t\t\tplaceholder=\"What needs to be done?\"\n\t\t\t\t\tautofocus\n\t\t\t\t\tclass=\"new-todo\"\n\t\t\t\t\tdata-todo=\"new\"\n\t\t\t\t/>\n\t\t\t</header>\n\t\t\t<!-- This section should be hidden by default and shown when there are todos -->\n\t\t\t<section class=\"main\" data-todo=\"main\">\n\t\t\t\t<input\n\t\t\t\t\tid=\"toggle-all\"\n\t\t\t\t\tclass=\"toggle-all\"\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tdata-todo=\"toggle-all\"\n\t\t\t\t/>\n\t\t\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t\t\t<ul class=\"todo-list\" data-todo=\"list\"></ul>\n\t\t\t</section>\n\t\t\t<!-- This footer should be hidden by default and shown when there are todos -->\n\t\t\t<footer class=\"footer\" data-todo=\"footer\">\n\t\t\t\t<!-- This should be `0 items left` by default -->\n\t\t\t\t<span class=\"todo-count\" data-todo=\"count\"\n\t\t\t\t\t><strong>0</strong> items left</span\n\t\t\t\t>\n\t\t\t\t<!-- Remove this if you don't implement routing -->\n\t\t\t\t<ul class=\"filters\" data-todo=\"filters\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<a class=\"selected\" href=\"#/\">All</a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<a href=\"#/active\">Active</a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<a href=\"#/completed\">Completed</a>\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t\t<!-- Hidden if no completed items are left ↓ -->\n\t\t\t\t<button class=\"clear-completed\" data-todo=\"clear-completed\">\n\t\t\t\t\tClear completed\n\t\t\t\t</button>\n\t\t\t</footer>\n\t\t</section>\n\t\t<footer class=\"info\">\n\t\t\t<p>Double-click to edit a todo</p>\n\t\t\t<p>Created by <a href=\"https://twitter.com/1Marc\">Marc Grabanski</a></p>\n\t\t\t<p>\n\t\t\t\tProject on GitHub:\n\t\t\t\t<a href=\"https://github.com/1Marc/todomvc-vanillajs-2022\"\n\t\t\t\t\t>Vanilla JS TodoMVC 2022</a\n\t\t\t\t>\n\t\t\t</p>\n\t\t</footer>\n\t\t<!-- Scripts here. Don't remove ↓ -->\n\t\t<script type=\"module\" src=\"js/app.js\"></script>\n\t</body>\n</html>\n",
      "encoding": "base64"
    },
    {
      "name": "js",
      "path": "js",
      "type": "dir",
      "size": 0,
      "children": [
        {
          "name": "app.js",
          "path": "js/app.js",
          "type": "file",
          "size": 4140,
          "content": "import { delegate, getURLHash, insertHTML, replaceHTML } from \"./helpers.js\";\nimport { TodoStore } from \"./store.js\";\n\nconst Todos = new TodoStore(\"todo-modern-vanillajs\");\n\nconst App = {\n\t$: {\n\t\tinput: document.querySelector('[data-todo=\"new\"]'),\n\t\ttoggleAll: document.querySelector('[data-todo=\"toggle-all\"]'),\n\t\tclear: document.querySelector('[data-todo=\"clear-completed\"]'),\n\t\tlist: document.querySelector('[data-todo=\"list\"]'),\n\t\tshowMain(show) {\n\t\t\tdocument.querySelector('[data-todo=\"main\"]').hidden = !show;\n\t\t},\n\t\tshowFooter(show) {\n\t\t\tdocument.querySelector('[data-todo=\"footer\"]').hidden = !show;\n\t\t},\n\t\tshowClear(show) {\n\t\t\tApp.$.clear.hidden = !show;\n\t\t},\n\t\tsetActiveFilter(filter) {\n\t\t\tdocument.querySelectorAll(`[data-todo=\"filters\"] a`).forEach((el) => {\n\t\t\t\tif (el.matches(`[href=\"#/${filter}\"]`)) {\n\t\t\t\t\tel.classList.add(\"selected\");\n\t\t\t\t} else {\n\t\t\t\t\tel.classList.remove(\"selected\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdisplayCount(count) {\n\t\t\treplaceHTML(\n\t\t\t\tdocument.querySelector('[data-todo=\"count\"]'),\n\t\t\t\t`\n\t\t\t\t<strong>${count}</strong>\n\t\t\t\t${count === 1 ? \"item\" : \"items\"} left\n\t\t\t`\n\t\t\t);\n\t\t},\n\t},\n\tinit() {\n\t\tTodos.addEventListener(\"save\", App.render);\n\t\tApp.filter = getURLHash();\n\t\twindow.addEventListener(\"hashchange\", () => {\n\t\t\tApp.filter = getURLHash();\n\t\t\tApp.render();\n\t\t});\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\tTodos.add({ title: e.target.value.trim() });\n\t\t\t\tApp.$.input.value = \"\";\n\t\t\t}\n\t\t});\n\t\tApp.$.toggleAll.addEventListener(\"click\", (e) => {\n\t\t\tTodos.toggleAll();\n\t\t});\n\t\tApp.$.clear.addEventListener(\"click\", (e) => {\n\t\t\tTodos.clearCompleted();\n\t\t});\n\t\tApp.bindTodoEvents();\n\t\tApp.render();\n\t},\n\ttodoEvent(event, selector, handler) {\n\t\tdelegate(App.$.list, selector, event, (e) => {\n\t\t\tlet $el = e.target.closest(\"[data-id]\");\n\t\t\thandler(Todos.get($el.dataset.id), $el, e);\n\t\t});\n\t},\n\tbindTodoEvents() {\n\t\tApp.todoEvent(\"click\", '[data-todo=\"destroy\"]', (todo) => Todos.remove(todo));\n\t\tApp.todoEvent(\"click\", '[data-todo=\"toggle\"]', (todo) => Todos.toggle(todo));\n\t\tApp.todoEvent(\"dblclick\", '[data-todo=\"label\"]', (_, $li) => {\n\t\t\t$li.classList.add(\"editing\");\n\t\t\t$li.querySelector('[data-todo=\"edit\"]').focus();\n\t\t});\n\t\tApp.todoEvent(\"keyup\", '[data-todo=\"edit\"]', (todo, $li, e) => {\n\t\t\tlet $input = $li.querySelector('[data-todo=\"edit\"]');\n\t\t\tif (e.key === \"Enter\" && $input.value.trim()) {\n\t\t\t\t$li.classList.remove(\"editing\");\n\t\t\t\tTodos.update({ ...todo, title: $input.value.trim() });\n\t\t\t}\n\t\t\tif (e.key === \"Escape\") {\n\t\t\t\tdocument.activeElement.blur();\n\t\t\t}\n\t\t});\n\t\tApp.todoEvent(\"focusout\", '[data-todo=\"edit\"]', (todo, $li, e) => {\n\t\t\tif ($li.classList.contains(\"editing\")) {\n\t\t\t\tApp.render();\n\t\t\t}\n\t\t});\n\t},\n\tcreateTodoItem(todo) {\n\t\tconst li = document.createElement(\"li\");\n\t\tli.dataset.id = todo.id;\n\t\tif (todo.completed) {\n\t\t\tli.classList.add(\"completed\");\n\t\t}\n\t\tinsertHTML(\n\t\t\tli,\n\t\t\t`\n\t\t\t<div class=\"view\">\n\t\t\t\t<input data-todo=\"toggle\" class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\n\t\t\t\t<label data-todo=\"label\"></label>\n\t\t\t\t<button class=\"destroy\" data-todo=\"destroy\"></button>\n\t\t\t</div>\n\t\t\t<input class=\"edit\" data-todo=\"edit\">\n\t\t`\n\t\t);\n\t\tli.querySelector('[data-todo=\"label\"]').textContent = todo.title;\n\t\tli.querySelector('[data-todo=\"edit\"]').value = todo.title;\n\t\treturn li;\n\t},\n\tsaveFocus() {\n\t\tconst $active = document.activeElement;\n\t\tconst $parent = $active && $active.closest(\"[data-id]\");\n\n\t\tApp.focusedSelector = $parent\n\t\t\t? `[data-id=\"${$parent.dataset.id}\"] ${$active.tagName.toLowerCase()}`\n\t\t\t: null;\n\t},\n\trestoreFocus() {\n\t\tif (!App.focusedSelector) return;\n\n\t\tconst $el = App.$.list.querySelector(App.focusedSelector);\n\t\tif ($el) $el.focus();\n\t},\n\trender() {\n\t\tconst count = Todos.all().length;\n\t\tApp.$.setActiveFilter(App.filter);\n\t\tApp.saveFocus();\n\t\tApp.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\t\tApp.restoreFocus();\n\t\tApp.$.showMain(count);\n\t\tApp.$.showFooter(count);\n\t\tApp.$.showClear(Todos.hasCompleted());\n\t\tApp.$.toggleAll.checked = Todos.isAllCompleted();\n\t\tApp.$.displayCount(Todos.all(\"active\").length);\n\t},\n};\n\nApp.init();\n",
          "encoding": "base64"
        },
        {
          "name": "helpers.js",
          "path": "js/helpers.js",
          "type": "file",
          "size": 408,
          "content": "export const getURLHash = () => document.location.hash.replace(/^#\\//, \"\");\n\nexport const delegate = (el, selector, event, handler) => {\n\tel.addEventListener(event, (e) => {\n\t\tif (e.target.matches(selector)) handler(e, el);\n\t});\n};\n\nexport const insertHTML = (el, html) => el.insertAdjacentHTML(\"afterbegin\", html);\n\nexport const replaceHTML = (el, html) => {\n\tel.replaceChildren();\n\tinsertHTML(el, html);\n};",
          "encoding": "base64"
        },
        {
          "name": "store.js",
          "path": "js/store.js",
          "type": "file",
          "size": 1799,
          "content": "export const TodoStore = class extends EventTarget {\n\tconstructor(localStorageKey) {\n\t\tsuper();\n\t\tthis.localStorageKey = localStorageKey;\n\t\tthis._readStorage();\n\t\t// handle todos edited in another window\n\t\twindow.addEventListener(\n\t\t\t\"storage\",\n\t\t\t() => {\n\t\t\t\tthis._readStorage();\n\t\t\t\tthis._save();\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t\t// GETTER methods\n\t\tthis.get = (id) => this.todos.find((todo) => todo.id === id);\n\t\tthis.isAllCompleted = () => this.todos.every((todo) => todo.completed);\n\t\tthis.hasCompleted = () => this.todos.some((todo) => todo.completed);\n\t\tthis.all = (filter) =>\n\t\t\tfilter === \"active\"\n\t\t\t\t? this.todos.filter((todo) => !todo.completed)\n\t\t\t\t: filter === \"completed\"\n\t\t\t\t? this.todos.filter((todo) => todo.completed)\n\t\t\t\t: this.todos;\n\t}\n\t_readStorage() {\n\t\tthis.todos = JSON.parse(window.localStorage.getItem(this.localStorageKey) || \"[]\");\n\t}\n\t_save() {\n\t\twindow.localStorage.setItem(\n\t\t\tthis.localStorageKey,\n\t\t\tJSON.stringify(this.todos)\n\t\t);\n\t\tthis.dispatchEvent(new CustomEvent(\"save\"));\n\t}\n\t// MUTATE methods\n\tadd({ title }) {\n\t\tthis.todos.push({\n\t\t\ttitle,\n\t\t\tcompleted: false,\n\t\t\tid: \"id_\" + Date.now(),\n\t\t});\n\t\tthis._save();\n\t}\n\tremove({ id }) {\n\t\tthis.todos = this.todos.filter((todo) => todo.id !== id);\n\t\tthis._save();\n\t}\n\ttoggle({ id }) {\n\t\tthis.todos = this.todos.map((todo) =>\n\t\t\ttodo.id === id ? { ...todo, completed: !todo.completed } : todo\n\t\t);\n\t\tthis._save();\n\t}\n\tclearCompleted() {\n\t\tthis.todos = this.todos.filter((todo) => !todo.completed);\n\t\tthis._save();\n\t}\n\tupdate(todo) {\n\t\tthis.todos = this.todos.map((t) => (t.id === todo.id ? todo : t));\n\t\tthis._save();\n\t}\n\ttoggleAll() {\n\t\tconst completed = !this.hasCompleted() || !this.isAllCompleted();\n\t\tthis.todos = this.todos.map((todo) => ({ ...todo, completed }));\n\t\tthis._save();\n\t}\n\trevert() {\n\t\tthis._save();\n\t}\n};\n",
          "encoding": "base64"
        }
      ]
    },
    {
      "name": "package-lock.json",
      "path": "package-lock.json",
      "type": "file",
      "size": 758,
      "content": "{\n  \"name\": \"todomvc-vanillajs-2022\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"dependencies\": {\n        \"todomvc-app-css\": \"^2.0.0\"\n      }\n    },\n    \"node_modules/todomvc-app-css\": {\n      \"version\": \"2.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/todomvc-app-css/-/todomvc-app-css-2.4.2.tgz\",\n      \"integrity\": \"sha512-ViAkQ7ed89rmhFIGRsT36njN+97z8+s3XsJnB8E2IKOq+/SLD/6PtSvmTtiwUcVk39qPcjAc/OyeDys4LoJUVg==\"\n    }\n  },\n  \"dependencies\": {\n    \"todomvc-app-css\": {\n      \"version\": \"2.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/todomvc-app-css/-/todomvc-app-css-2.4.2.tgz\",\n      \"integrity\": \"sha512-ViAkQ7ed89rmhFIGRsT36njN+97z8+s3XsJnB8E2IKOq+/SLD/6PtSvmTtiwUcVk39qPcjAc/OyeDys4LoJUVg==\"\n    }\n  }\n}",
      "encoding": "base64"
    },
    {
      "name": "package.json",
      "path": "package.json",
      "type": "file",
      "size": 299,
      "content": "{\n\t\"private\": true,\n\t\"scripts\": {\n\t\t\"start\": \"python3 -m http.server 1337\",\n\t\t\"format\": \"npx prettier --write .\"\n\t},\n\t\"dependencies\": {\n\t\t\"todomvc-app-css\": \"^2.0.0\"\n\t},\n\t\"dependenciesComments\": {\n\t\t\"todomvc-app-css\": \"TodoMVC boilerplate CSS (not in use, just copy/pasted into css/index.css)\"\n\t}\n}\n",
      "encoding": "base64"
    },
    {
      "name": "readme.md",
      "path": "readme.md",
      "type": "file",
      "size": 4182,
      "content": "# TodoMVC App Written in Modern Vanilla JS\n\nIt seems straightforward to build reasonably complex things using only modern JavaScript these days! We can take advantage of most newer features without hacks or polyfills.\n\nHere's my Vanilla JavaScript implementation:\n\n- ~200 lines of code total (compared to the official vanilla JS TodoMVC from 6 years ago was 900+ LOC)\n- No build tools\n- JavaScript modules\n\n<a href=\"https://1marc.github.io/modern-todomvc-vanillajs/\" target=\"_new\">View the working example on GitHub pages</a>\n\nCriticism, PRs, and feedback are welcome!\n\n## Project Blog Post:\n\n[<img alt=\"Modern Vanilla JavaScript TodoMVC in 2022 Article\" width=\"750\" src=\"https://static.frontendmasters.com/assets/blog/2022/vanilla-javascript-todomvc.jpg\" />](https://frontendmasters.com/blog/vanilla-javascript-todomvc/)\n\n# Additional Examples\n\n## Initial Code\n\nThe initial version came together in only 60 minutes, then ~30 min of refactoring: [see the commit here](https://github.com/1Marc/modern-todomvc-vanillajs/tree/fb3c61ed104c440f0c29e3a074b6777c791aa2f6)\n\nHow quick it was to get working was what initially got me pumped about all of the progress in the core JavaScript language.\n\n## App Architecture\n\nPeople were concerned about the scalability of apps like this since there are no components, and it's all one App. So I extracted the TodoList and App components and wired the components together on the app-architecture branch.\n\nBranch: https://github.com/1Marc/modern-todomvc-vanillajs/tree/app-architecture\n\nNote: I realize it is silly to say the word \"scalable\" in the context of a todo app, but this should be looked at as a blueprint for building something more extensive. I plan to make more ambitious examples in the future to show what's possible.\n\n## More Granular & Performant DOM Updates for Large Lists\n\nSince I'm rendering everything on every update of the model from scratch, this can cause performance issues on long lists.\n\nHere's a branch sending specific events with context from the model so we can make DOM updates more selectively as we need them ([see code diff](https://github.com/1Marc/modern-todomvc-vanillajs/commit/fc89da1a6bd15489d5256575a4e193e11efd8d43)).\n\nBranch: https://github.com/1Marc/modern-todomvc-vanillajs/tree/performant-rendering\n\n## More Performant DOM Updates for Large Lists with lit-html (Plus animations!)\n\nWe can achieve the same performant DOM updates with far less code by adopting lit-html using the repeat directive ([see code diff](https://github.com/1Marc/modern-todomvc-vanillajs/commit/ef86a73166029991dc88c649f7ec4931a2a96c86)).\n\nBranch: https://github.com/1Marc/modern-todomvc-vanillajs/tree/animation-lithtml\n\n## TypeScript\n\nHere's the code base with TypeScript: https://github.com/1Marc/modern-todomvc-vanillaj/tree/typescript\n\n## TypeScript + ESLint\n\nHere's the code base with TypeScript and linting with ESLint: https://github.com/1Marc/modern-todomvc-vanillajs/tree/typescript-eslint\n\n# Example UI Components Using this Architecture\n\n[Vanilla JavaScript View Switcher Based on Hash Change](https://codepen.io/1Marc/pen/poLmXZR)\n\n<a href=\"https://codepen.io/1Marc/pen/poLmXZR\"><img src=\"https://user-images.githubusercontent.com/19269/189225506-1c1838e1-5b2a-408b-802a-dfe71b2f703c.png\" width=\"500\" /></a>\n\n[Vanilla JavaScript Countdown Clock](https://codepen.io/1Marc/pen/bGvPRdy)\n\n<a href=\"https://codepen.io/1Marc/pen/bGvPRdy\"><img src=\"https://user-images.githubusercontent.com/19269/189225317-bb2ce1fb-a734-4193-beb1-670b5d6fbb04.png\" width=\"500\" /></a>\n\n## License\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/deed.en_US\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"http://i.creativecommons.org/l/by/4.0/80x15.png\" /></a><br />This <span xmlns:dct=\"http://purl.org/dc/terms/\" href=\"http://purl.org/dc/dcmitype/InteractiveResource\" rel=\"dct:type\">work</span> by <a xmlns:cc=\"http://creativecommons.org/ns#\" href=\"http://sindresorhus.com\" property=\"cc:attributionName\" rel=\"cc:attributionURL\">TasteJS</a> is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/deed.en_US\">Creative Commons Attribution 4.0 International License</a>.\n",
      "encoding": "base64"
    }
  ],
  "aiAnalysis": [
    {
      "file": "app-readme.md",
      "summary": "This file provides a template for a framework's TodoMVC implementation, detailing resources, articles, and support channels. It includes sections for implementation notes and credit, serving as a boilerplate for documenting a specific TodoMVC project.",
      "imports": [],
      "functions": [],
      "classes": []
    },
    {
      "file": "css/index.css",
      "summary": "This CSS file defines the comprehensive styling for a TodoMVC application, encompassing general layout, typography, and responsive adjustments. It provides detailed styles for core UI elements such as the main application container, input fields, individual todo items (including toggle, label, and destroy buttons), the footer, todo count, and filter navigation. The styles also include various pseudo-classes and media queries for enhanced user experience and responsiveness.",
      "imports": [],
      "functions": [],
      "classes": []
    },
    {
      "file": "index.html",
      "summary": "This is the main HTML file for a TodoMVC application, establishing the document structure, character encoding, and viewport settings. It links to the application's CSS and loads the primary JavaScript module, `js/app.js`, defining the core UI layout for adding, displaying, and managing todo items, along with filtering options and a footer containing application information. The structure includes placeholders for dynamic content that will be populated by JavaScript.",
      "imports": [
        "css/index.css",
        "js/app.js"
      ],
      "functions": [],
      "classes": []
    },
    {
      "file": "js/app.js",
      "summary": "This JavaScript file serves as the main application controller for the TodoMVC implementation, orchestrating user interactions and UI rendering. It leverages a `TodoStore` for data management and helper functions for DOM manipulation, dynamically updating the todo list, handling input, managing filters via URL hash, and binding various event listeners to create an interactive user experience. The application object `App` encapsulates all UI logic and state synchronization.",
      "imports": [
        "./helpers.js",
        "./store.js"
      ],
      "functions": [],
      "classes": [
        {
          "name": "App",
          "description": "The main application controller for the TodoMVC application, handling DOM manipulation, event binding, and interaction with the TodoStore. It acts as a central module managing the UI state and user interactions by delegating events and rendering the view.",
          "functions": [
            {
              "name": "showMain",
              "signature": "showMain(show)",
              "description": "Controls the visibility of the main todo list section based on the 'show' boolean."
            },
            {
              "name": "showFooter",
              "signature": "showFooter(show)",
              "description": "Controls the visibility of the application's footer section based on the 'show' boolean."
            },
            {
              "name": "showClear",
              "signature": "showClear(show)",
              "description": "Controls the visibility of the 'Clear completed' button based on the 'show' boolean."
            },
            {
              "name": "setActiveFilter",
              "signature": "setActiveFilter(filter)",
              "description": "Applies the 'selected' class to the appropriate filter link within the navigation based on the current filter state (e.g., 'all', 'active', 'completed')."
            },
            {
              "name": "displayCount",
              "signature": "displayCount(count)",
              "description": "Updates the UI element showing the number of active todo items remaining, including proper singular/plural formatting."
            },
            {
              "name": "init",
              "signature": "init()",
              "description": "Initializes the application by setting up event listeners for the TodoStore, URL hash changes, new todo input, toggle all, and clear completed actions. It then binds todo-specific events and renders the initial UI state."
            },
            {
              "name": "todoEvent",
              "signature": "todoEvent(event, selector, handler)",
              "description": "A helper function to delegate events on the todo list, identifying the closest todo item (`[data-id]`) and passing its corresponding todo object and element to a specified handler function."
            },
            {
              "name": "bindTodoEvents",
              "signature": "bindTodoEvents()",
              "description": "Binds specific event handlers for individual todo items, including 'click' for destroy and toggle actions, 'dblclick' to enable editing, 'keyup' for saving/canceling edits, and 'focusout' for committing edits."
            },
            {
              "name": "createTodoItem",
              "signature": "createTodoItem(todo)",
              "description": "Creates and returns an HTML list item (<li>) element for a given todo object, dynamically setting its content, completion status, and necessary data attributes for interaction."
            },
            {
              "name": "saveFocus",
              "signature": "saveFocus()",
              "description": "Saves a CSS selector for the currently focused element within a todo item, allowing focus to be restored after the DOM is re-rendered."
            },
            {
              "name": "restoreFocus",
              "signature": "restoreFocus()",
              "description": "Restores focus to a previously saved element, if a selector exists, after the DOM has been updated, ensuring a smooth user experience during re-renders."
            },
            {
              "name": "render",
              "signature": "render()",
              "description": "Renders the entire TodoMVC application UI, which includes updating the filter highlights, replacing the todo list with current items, showing/hiding main and footer sections, updating the clear completed button, toggle all checkbox, and the active todo count."
            }
          ]
        }
      ]
    },
    {
      "file": "js/helpers.js",
      "summary": "This JavaScript file provides a collection of utility functions designed to simplify common DOM manipulation tasks and URL hash parsing for the TodoMVC application. These helpers enable efficient event delegation to handle dynamic elements, controlled HTML insertion and replacement for updating UI sections, and easy extraction of the current routing hash from the browser's URL.",
      "imports": [],
      "functions": [
        {
          "name": "getURLHash",
          "signature": "getURLHash()",
          "description": "Extracts the current URL hash, removing the '#/' prefix to provide a clean filter string for routing."
        },
        {
          "name": "delegate",
          "signature": "delegate(el, selector, event, handler)",
          "description": "Attaches an event listener to a parent element and delegates the event to a child element matching a given CSS selector, executing a handler function when triggered."
        },
        {
          "name": "insertHTML",
          "signature": "insertHTML(el, html)",
          "description": "Inserts the provided HTML string into the specified element's content, positioned immediately after its beginning ('afterbegin')."
        },
        {
          "name": "replaceHTML",
          "signature": "replaceHTML(el, html)",
          "description": "Clears all children of the specified element and then inserts new HTML content into it."
        }
      ],
      "classes": []
    },
    {
      "file": "js/store.js",
      "summary": "This JavaScript file defines the `TodoStore` class, which is responsible for managing the state and persistence of todo items. It leverages `localStorage` for data storage, extending `EventTarget` to dispatch custom events on data changes, specifically a 'save' event. The class provides a comprehensive API for CRUD operations, filtering, and checking the completion status of todos within a TodoMVC application, ensuring data consistency across sessions.",
      "imports": [],
      "functions": [],
      "classes": [
        {
          "name": "TodoStore(EventTarget)",
          "description": "Manages the state and persistence of todo items in `localStorage`, extending `EventTarget` to dispatch custom 'save' events. It provides methods for adding, removing, toggling, updating, and filtering todo items, as well as checking their completion status and handling cross-window storage updates.",
          "functions": [
            {
              "name": "constructor",
              "signature": "constructor(localStorageKey)",
              "description": "Initializes the TodoStore with a specified `localStorageKey`, loads existing todos, sets up an event listener for `storage` changes across windows, and defines several getter methods for convenient access to todo data."
            },
            {
              "name": "_readStorage",
              "signature": "_readStorage()",
              "description": "Reads the current list of todo items from `localStorage` associated with the store's key and parses the JSON string into the `todos` array."
            },
            {
              "name": "_save",
              "signature": "_save()",
              "description": "Serializes the current `todos` array to a JSON string, saves it to `localStorage`, and dispatches a custom 'save' event to notify listeners of data changes."
            },
            {
              "name": "get",
              "signature": "get(id)",
              "description": "Retrieves a single todo item from the current list by its unique identifier."
            },
            {
              "name": "isAllCompleted",
              "signature": "isAllCompleted()",
              "description": "Checks if all todo items currently in the list are marked as completed."
            },
            {
              "name": "hasCompleted",
              "signature": "hasCompleted()",
              "description": "Checks if there is at least one todo item in the list that is marked as completed."
            },
            {
              "name": "all",
              "signature": "all(filter)",
              "description": "Returns a filtered list of todo items based on the provided filter string ('active' to get incomplete, 'completed' to get completed, or all if no filter is specified)."
            },
            {
              "name": "add",
              "signature": "add({ title })",
              "description": "Adds a new todo item with the given title, a unique ID, and an initial 'completed: false' status to the list, then saves the updated list."
            },
            {
              "name": "remove",
              "signature": "remove({ id })",
              "description": "Removes a todo item identified by its ID from the list and saves the updated list to `localStorage`."
            },
            {
              "name": "toggle",
              "signature": "toggle({ id })",
              "description": "Toggles the completion status of a specific todo item by its ID (from completed to active or vice versa) and saves the updated list."
            },
            {
              "name": "clearCompleted",
              "signature": "clearCompleted()",
              "description": "Removes all todo items that are currently marked as completed from the list and saves the modified list."
            },
            {
              "name": "update",
              "signature": "update(todo)",
              "description": "Updates an existing todo item with new data by finding it based on its ID and replacing its properties, then saves the updated list."
            },
            {
              "name": "toggleAll",
              "signature": "toggleAll()",
              "description": "Toggles the completion status for all todo items in the list; if any are incomplete, all become complete, otherwise all become incomplete, and the list is saved."
            },
            {
              "name": "revert",
              "signature": "revert()",
              "description": "Saves the current state of the todos to localStorage, effectively ensuring persistence, though it's a no-operation if no explicit changes were made since the last `_save` call."
            }
          ]
        }
      ]
    },
    {
      "file": "package-lock.json",
      "summary": "This `package-lock.json` file ensures consistent dependency installations for the `todomvc-vanillajs-2022` project by precisely detailing the dependency tree. It specifies that `todomvc-app-css` version `2.4.2` is installed, providing its exact `resolved` URL and `integrity` hash to guarantee reproducible builds across different environments.",
      "imports": [],
      "functions": [],
      "classes": []
    },
    {
      "file": "package.json",
      "summary": "This `package.json` file defines metadata for the `todomvc-vanillajs-2022` project, including scripts for starting a local HTTP server (`python3 -m http.server`) and formatting code with Prettier. It lists `todomvc-app-css` as a dependency, although a comment clarifies that its CSS content is copied directly into `css/index.css` rather than being used via `node_modules`.",
      "imports": [],
      "functions": [],
      "classes": []
    },
    {
      "file": "readme.md",
      "summary": "This `README.md` introduces a TodoMVC application built with modern Vanilla JavaScript, emphasizing its conciseness, absence of build tools, and reliance on ES modules. It provides a live demo link, invites contributions, and documents various experimental branches showcasing different architectural patterns, performance optimizations (including `lit-html`), and TypeScript integrations. The file also showcases related UI component examples and details the project's Creative Commons license.",
      "imports": [],
      "functions": [],
      "classes": []
    }
  ],
  "abstractionAnalysis": {
    "abstractions": [
      {
        "name": "TodoStore",
        "description": "Manages the collection of todo items, including adding, removing, updating, filtering, and persisting them to local storage. It also notifies listeners of changes to its state. It's like a librarian for your tasks, keeping track of all your to-do notes, what's done, what's pending, and saving them for later.",
        "category": "class",
        "file_indices": [
          3,
          5
        ]
      },
      {
        "name": "Application Controller",
        "description": "The central orchestrator of the application, responsible for initializing the UI, binding user interactions to data store operations, and rendering updates to the view. It's like a stage director, telling the actors (UI elements) what to do and responding to audience (user) actions.",
        "category": "component",
        "file_indices": [
          3
        ]
      },
      {
        "name": "Todo Item Renderer",
        "description": "A function responsible for creating and updating the HTML representation of a single todo item. It ensures the UI accurately reflects the item's state (e.g., completed, editing). It's like a blueprint and construction crew for a single brick in a wall, making sure it looks right and has the correct properties.",
        "category": "component",
        "file_indices": [
          3
        ]
      },
      {
        "name": "UI Event Delegation",
        "description": "A pattern for efficiently handling user interactions on dynamically rendered elements by attaching a single event listener to a parent element. It then determines the specific child element that triggered the event. It's like a receptionist at a large office building who listens for all incoming calls and then directs them to the correct department or person, rather than each person having their own phone line.",
        "category": "pattern",
        "file_indices": [
          3,
          4
        ]
      },
      {
        "name": "Local Storage Persistence",
        "description": "The mechanism used to store the application's data (todo items) in the browser's local storage, ensuring that the data is saved and reloaded even after the browser is closed. It also listens for changes from other browser tabs. It's like a persistent notebook where your tasks are written down and kept safe, even if you close the book, and can be synchronized if you have multiple copies open.",
        "category": "service",
        "file_indices": [
          5
        ]
      },
      {
        "name": "View Router",
        "description": "Determines which subset of todo items (all, active, or completed) should be displayed based on the URL hash. It updates the UI's filter selection accordingly. It's like a map that guides you to different sections of a park (all items, active items, completed items) based on the path you choose.",
        "category": "service",
        "file_indices": [
          3,
          4
        ]
      },
      {
        "name": "DOM Helpers",
        "description": "A collection of utility functions that simplify common DOM manipulation tasks, such as inserting or replacing HTML content within an element. It's like a set of specialized tools (e.g., a hammer, screwdriver) that make working with a building's structure easier and more efficient.",
        "category": "service",
        "file_indices": [
          3,
          4
        ]
      }
    ]
  },
  "relationshipAnalysis": {
    "summary": "This project is a simple **To-Do List application** that helps you *organize your tasks*. You can easily **add new tasks**, *mark them as complete*, edit them, or remove them. All your tasks are *automatically saved* in your browser's local storage, ensuring they persist even if you close the app, and you can also *filter tasks* to see only active, completed, or all of them.",
    "relationships": [
      {
        "from": 1,
        "to": 0,
        "label": "Manages Todos"
      },
      {
        "from": 0,
        "to": 1,
        "label": "Notifies of Saves"
      },
      {
        "from": 0,
        "to": 4,
        "label": "Uses Persistence"
      },
      {
        "from": 1,
        "to": 3,
        "label": "Delegates Events"
      },
      {
        "from": 1,
        "to": 5,
        "label": "Updates Filter"
      },
      {
        "from": 1,
        "to": 2,
        "label": "Renders Todo HTML"
      },
      {
        "from": 2,
        "to": 6,
        "label": "Uses DOM Helpers"
      },
      {
        "from": 1,
        "to": 6,
        "label": "Updates UI"
      }
    ]
  },
  "chapterOrder": {
    "orderedIndices": [
      1,
      0,
      4,
      2,
      6,
      3,
      5
    ]
  },
  "chapters": {
    "chapters": [
      "# Chapter 1: Application Controller\n\nWelcome to the first chapter of our tutorial! In this project, we're building a \"Todo\" application, which helps you keep track of your tasks. Before we dive into the code, let's understand the different parts that make our application work together. Think of it like a team, where each member has a specific job.\n\nHere’s a quick overview of our team members:\n\n*   **TodoStore:** Manages the collection of todo items, including adding, removing, updating, filtering, and persisting them to local storage. It also notifies listeners of changes to its state. It's like a librarian for your tasks, keeping track of all your to-do notes, what's done, what's pending, and saving them for later.\n*   **Application Controller:** The central orchestrator of the application, responsible for initializing the UI, binding user interactions to data store operations, and rendering updates to the view. It's like a stage director, telling the actors (UI elements) what to do and responding to audience (user) actions.\n*   **Todo Item Renderer:** A function responsible for creating and updating the HTML representation of a single todo item. It ensures the UI accurately reflects the item's state (e.g., completed, editing). It's like a blueprint and construction crew for a single brick in a wall, making sure it looks right and has the correct properties.\n*   **UI Event Delegation:** A pattern for efficiently handling user interactions on dynamically rendered elements by attaching a single event listener to a parent element. It then determines the specific child element that triggered the event. It's like a receptionist at a large office building who listens for all incoming calls and then directs them to the correct department or person, rather than each person having their own phone line.\n*   **Local Storage Persistence:** The mechanism used to store the application's data (todo items) in the browser's local storage, ensuring that the data is saved and reloaded even after the browser is closed. It also listens for changes from other browser tabs. It's like a persistent notebook where your tasks are written down and kept safe, even if you close the book, and can be synchronized if you have multiple copies open.\n*   **View Router:** Determines which subset of todo items (all, active, or completed) should be displayed based on the URL hash. It updates the UI's filter selection accordingly. It's like a map that guides you to different sections of a park (all items, active items, completed items) based on the path you choose.\n*   **DOM Helpers:** A collection of utility functions that simplify common DOM manipulation tasks, such as inserting or replacing HTML content within an element. It's like a set of specialized tools (e.g., a hammer, screwdriver) that make working with a building's structure easier and more efficient.\n\n***\n\n## What Problem Does the Application Controller Solve?\n\nImagine you're running a play. You have actors (the different parts of your app's display, like a task list), props (the data, like your actual todo items), and an audience (the user). Who tells the actors what to do? Who makes sure they respond when the audience claps or boos? That's the job of the **Application Controller**.\n\nIn our ToDo app, when you type a new task and press Enter, a lot of things need to happen:\n1.  The app needs to *know* you typed something.\n2.  It needs to *save* that new task.\n3.  It needs to *show* that new task on the screen.\n\nWithout a central \"director,\" each part of your app would have to figure this out on its own, leading to a lot of confusion and tangled code. The **Application Controller** steps in to handle all these coordination tasks.\n\n## The Stage Director of Our App\n\nThe Application Controller is like the conductor of an orchestra or the director of a play. It doesn't play the instruments or act in the play itself, but it makes sure everyone plays their part at the right time and in harmony.\n\nIts main responsibilities are:\n*   **Initialization:** Getting everything set up when the app starts.\n*   **Event Handling:** Listening for what the user does (like typing in a task, clicking \"mark complete\").\n*   **Data Management:** Telling the data storage ([TodoStore](02_todostore.md)) what to do based on user actions.\n*   **UI Updates:** Making sure the screen (the \"View\") always shows the most current information.\n\n## How It Works: Adding a New ToDo\n\nLet's walk through our concrete example: how does the **Application Controller** make it possible to add a new ToDo item?\n\n### 1. Starting the Show: `App.init()`\n\nWhen our application first loads, the **Application Controller** (named `App` in our code) kicks everything off with its `init()` method.\n\n```javascript\n// js/app.js\n// ... (imports and Todos setup) ...\n\nconst App = {\n\t// ... (other parts of App) ...\n\tinit() {\n\t\t// Listen for changes in our data store\n\t\tTodos.addEventListener(\"save\", App.render);\n\n\t\t// Listen for user typing a new todo\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\t// 1. Tell the TodoStore to add the new item\n\t\t\t\tTodos.add({ title: e.target.value.trim() });\n\t\t\t\t// 2. Clear the input field\n\t\t\t\tApp.$.input.value = \"\";\n\t\t\t}\n\t\t});\n\t\t// ... (other initializations and event listeners) ...\n\t\tApp.render(); // Show initial todos\n\t},\n\t// ... (rest of App) ...\n};\n\nApp.init(); // This line starts our app!\n```\nIn this snippet:\n*   `App.init()` is the very first thing called when the app starts. It's like the director shouting \"Action!\"\n*   Inside `init()`, we set up various \"listeners.\" These are like ears, waiting for specific things to happen.\n*   One listener is for `Todos.addEventListener(\"save\", App.render);`. This means: \"Whenever our [TodoStore](02_todostore.md) saves data, run `App.render()` to update the screen.\" This is super important because it ensures our UI is *always* up-to-date.\n*   Another listener is attached to `App.$.input` (which is our input field for new todos). It waits for you to press a key (`keyup`). If you press `Enter` and have typed something, it proceeds to add the todo.\n\n### 2. User Action: Typing a New ToDo\n\nWhen you type \"Buy milk\" into the input box and press `Enter`:\n\n```javascript\n// Inside App.init() in js/app.js\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\tTodos.add({ title: e.target.value.trim() }); // This line is crucial!\n\t\t\t\tApp.$.input.value = \"\";\n\t\t\t}\n\t\t});\n```\n*   The `keyup` event listener detects your `Enter` key press.\n*   It then calls `Todos.add({ title: e.target.value.trim() });`. This is the **Application Controller** telling the [TodoStore](02_todostore.md) (our librarian) to add a new book (a new todo item) with the title \"Buy milk\".\n*   After adding, it clears the input field (`App.$.input.value = \"\";`).\n\n### 3. Updating the Display: `App.render()`\n\nOnce the [TodoStore](02_todostore.md) has saved the new todo, it signals back that data has changed. Because we set up `Todos.addEventListener(\"save\", App.render);` earlier, the `App.render()` method is automatically called.\n\nThe `render()` method is the **Application Controller's** job to repaint the stage. It fetches the latest list of todos and updates the entire display.\n\n```javascript\n// js/app.js\n// ... (App object) ...\n\trender() {\n\t\t// Get all todo items, filtered by what the user wants to see (all, active, completed)\n\t\tconst count = Todos.all().length;\n\n\t\t// Update the list of todo items on the screen\n\t\tApp.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\n\t\t// Show/hide main section, footer, clear button based on todo count\n\t\tApp.$.showMain(count);\n\t\tApp.$.showFooter(count);\n\t\tApp.$.showClear(Todos.hasCompleted());\n\n\t\t// Update other UI elements like the \"items left\" counter\n\t\tApp.$.displayCount(Todos.all(\"active\").length);\n\t},\n// ... (rest of App) ...\n```\n*   `App.render()` is responsible for updating *all* parts of the UI that depend on the list of todos.\n*   `App.$.list.replaceChildren(...)` is where the magic happens: it takes the current list of todos from the [TodoStore](02_todostore.md), creates HTML elements for each, and updates the `<ul>` element in our app. It uses `App.createTodoItem(todo)` which, behind the scenes, relies on our [Todo Item Renderer](04_todo_item_renderer.md) concept.\n*   Other helper functions like `App.$.showMain(count)` or `App.$.displayCount(...)` are called to update things like the visibility of the footer or the \"X items left\" message.\n\n## How it All Connects: Under the Hood\n\nLet's visualize the flow when you add a new todo:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as Application Controller\n    participant Todos as TodoStore\n    participant UI as User Interface\n\n    User->>UI: Types \"Buy milk\" and presses Enter\n    UI->>App: \"keyup\" event detected\n    App->>Todos: add({ title: \"Buy milk\" })\n    Todos->>Todos: Saves new todo internally (and to local storage)\n    Todos->>App: Notifies \"save\" event\n    App->>Todos: all(App.filter) (gets updated list)\n    App->>UI: Calls render() to update the display\n    UI->>User: Displays \"Buy milk\" in the todo list\n```\n\nThis sequence shows how the **Application Controller** acts as the central hub, coordinating the user's action with the data storage and then updating the visual display.\n\n### Diving into the Code (`js/app.js`)\n\nHere's how parts of the `App` object in `js/app.js` specifically handle this flow:\n\n#### Initial Setup (`init` method)\n\nThis is where the `App` (our **Application Controller**) first sets up all the event listeners. It's like the director assigning roles and cue sheets to everyone before the play begins.\n\n```javascript\n// js/app.js\nimport { delegate, getURLHash, insertHTML, replaceHTML } from \"./helpers.js\";\nimport { TodoStore } from \"./store.js\"; // This is our TodoStore!\n\nconst Todos = new TodoStore(\"todo-modern-vanillajs\"); // Create an instance of TodoStore\n\nconst App = {\n\t// Our \"App\" object is the Application Controller\n\t// `$` holds references to important UI elements\n\t$: {\n\t\tinput: document.querySelector('[data-todo=\"new\"]'), // The input field for new todos\n\t\tlist: document.querySelector('[data-todo=\"list\"]'), // The <ul> where todos are displayed\n\t\t// ... (other UI elements) ...\n\t},\n\tinit() {\n\t\t// Tell App to re-render the UI whenever the TodoStore changes\n\t\tTodos.addEventListener(\"save\", App.render);\n\n\t\t// Handle adding new todos when the user types in the input field\n\t\tApp.$.input.addEventListener(\"keyup\", (e) => {\n\t\t\tif (e.key === \"Enter\" && e.target.value.trim()) {\n\t\t\t\tTodos.add({ title: e.target.value.trim() }); // Tell TodoStore to add a todo\n\t\t\t\tApp.$.input.value = \"\"; // Clear the input field\n\t\t\t}\n\t\t});\n\t\t// ... (other event listeners for toggle all, clear completed, etc.) ...\n\n\t\tApp.render(); // Call render() initially to show any existing todos\n\t},\n    // ... (rest of App methods) ...\n};\n\nApp.init(); // This line runs when the browser loads js/app.js\n```\n*   `Todos.addEventListener(\"save\", App.render);`: This line is key. It tells the `App` that whenever the `Todos` (our [TodoStore](02_todostore.md)) saves something (a new todo, an updated todo, a deleted todo), the `App.render` function should be called. This ensures our UI always reflects the latest data.\n*   `App.$.input.addEventListener(\"keyup\", ...)`: This attaches a listener to the input field. When a key is released, it checks if it was `Enter` and if there's text. If so, it uses `Todos.add()` to store the new item and then clears the input.\n\n#### Rendering the View (`render` method)\n\nThis method is the heart of how the **Application Controller** updates what you see on the screen.\n\n```javascript\n// js/app.js\n// ... (App object) ...\n\tcreateTodoItem(todo) {\n\t\t// This helper creates the actual HTML <li> element for a single todo.\n\t\t// It's part of the Application Controller but works closely with\n\t\t// the concept of a [Todo Item Renderer](04_todo_item_renderer.md).\n\t\tconst li = document.createElement(\"li\");\n\t\tli.dataset.id = todo.id; // Store the todo's ID on the HTML element\n\t\tif (todo.completed) {\n\t\t\tli.classList.add(\"completed\");\n\t\t}\n\t\t// ... (inserts HTML content for view, toggle, label, destroy button, edit input) ...\n\t\tli.querySelector('[data-todo=\"label\"]').textContent = todo.title;\n\t\tli.querySelector('[data-todo=\"edit\"]').value = todo.title;\n\t\treturn li;\n\t},\n\trender() {\n\t\t// Get how many todos we have in total\n\t\tconst count = Todos.all().length;\n\n\t\t// Update the list section by replacing its children\n\t\tApp.$.list.replaceChildren(\n\t\t\t// Get all todos (filtered by current App.filter) and convert each into an HTML <li>\n\t\t\t...Todos.all(App.filter).map((todo) => App.createTodoItem(todo))\n\t\t);\n\n\t\t// Show/hide the main and footer sections if there are any todos\n\t\tApp.$.showMain(count);\n\t\tApp.$.showFooter(count);\n\n\t\t// Update the count of active items displayed\n\t\tApp.$.displayCount(Todos.all(\"active\").length);\n\t},\n// ... (rest of App methods) ...\n```\n*   `App.createTodoItem(todo)`: This is a helper function inside `App` that takes a `todo` object (like `{ id: '123', title: 'Buy milk', completed: false }`) and turns it into a ready-to-display HTML `<li>` element. This concept is explored further in [Todo Item Renderer](04_todo_item_renderer.md).\n*   `App.$.list.replaceChildren(...)`: This line is powerful! It clears out all existing todo items from the `<ul>` element and then inserts new `<li>` elements, generated by calling `App.createTodoItem()` for *every* todo item currently in the [TodoStore](02_todostore.md) (and filtered by what the user wants to see).\n*   The other `App.$.show...` and `App.$.displayCount` calls simply update other parts of the UI, like showing or hiding the footer, or updating the \"X items left\" message, based on the current state of todos.\n\n## Conclusion\n\nThe **Application Controller** is the central brain of our ToDo app. It handles the initial setup, listens to everything the user does, tells the data storage ([TodoStore](02_todostore.md)) what to save or change, and then makes sure the entire display is updated correctly. It's the director ensuring all parts of the show run smoothly and the audience (you!) always sees the correct and latest information.\n\nNow that we understand how the **Application Controller** orchestrates everything, let's dive into the details of the data itself. How does our app actually store and manage all those todo items? We'll explore this in the next chapter: [TodoStore](02_todostore.md).",
      "# Chapter 2: TodoStore\n\nWelcome back! In our last chapter, we met the [Application Controller](01_application_controller.md), the busy director telling everyone what to do. But what exactly is it directing? It's directing the management of our \"todo\" items – all the tasks we want to keep track of. This is where our next key player comes in: the `TodoStore`.\n\n### What Problem Does the TodoStore Solve?\n\nImagine you have a stack of sticky notes, each with a task written on it. Some are done, some are urgent, some are just ideas. If you want to find all the urgent ones, or throw away the done ones, or add a new one, you'd have to sort through them all yourself. That's a lot of work!\n\nThe `TodoStore` is like your personal, super-organized librarian for these sticky notes. Instead of you rummaging through them, you just tell the librarian what you need, and they handle the details.\n\n**Our main goal in this chapter is to understand how we can add a new todo item and have the `TodoStore` manage it for us.**\n\n### Meet the TodoStore: Your Task Librarian\n\nThe `TodoStore` is a dedicated part of our application that holds **all** your todo items. It's not just a simple list; it's a smart manager that knows how to:\n\n*   **Add** new tasks.\n*   **Remove** tasks you no longer need.\n*   **Update** tasks (like changing their name or marking them as \"done\").\n*   **Filter** tasks (show only active ones, or only completed ones).\n*   **Save** your tasks so they don't disappear when you close your browser.\n*   **Notify** other parts of the app when anything changes, so they can update what you see on the screen.\n\nIt's the central source of truth for all your task data.\n\n### How to Use the TodoStore: Adding a New Task\n\nLet's look at how the [Application Controller](01_application_controller.md) uses the `TodoStore` to add a new task.\n\nIn `app.js`, you'll see this line near the top:\n\n```javascript\nimport { TodoStore } from \"./store.js\"; // Bringing in our librarian!\n\nconst Todos = new TodoStore(\"todo-modern-vanillajs\"); // Creating an instance of our librarian\n```\n\nThis creates a specific `TodoStore` object named `Todos`. Think of `Todos` as our actual librarian, ready to take instructions. The text `\"todo-modern-vanillajs\"` is just a special name for where our tasks will be saved, like the name of a specific shelf in the library.\n\nNow, let's see how `Todos` is asked to add a new task. Remember from [Chapter 1: Application Controller](01_application_controller.md) that the Application Controller listens for when you type a new task and press Enter:\n\n```javascript\n// From js/app.js\nApp.$.input.addEventListener(\"keyup\", (e) => {\n    if (e.key === \"Enter\" && e.target.value.trim()) {\n        Todos.add({ title: e.target.value.trim() }); // Here's where we tell the librarian!\n        App.$.input.value = \"\"; // Clear the input box\n    }\n});\n```\n\nWhen you type something like \"Buy milk\" into the input box and press Enter, this code runs. The important line is `Todos.add({ title: e.target.value.trim() });`.\n\n*   `Todos` is our `TodoStore` librarian.\n*   `.add()` is the instruction we're giving the librarian: \"Please add a new task!\"\n*   `{ title: \"Buy milk\" }` is the \"sticky note\" we're handing to the librarian. It tells them the task's title.\n\nAfter this line runs, the `TodoStore` takes over to actually add \"Buy milk\" to its collection and make sure it's saved.\n\n### Under the Hood: How TodoStore Adds a Task\n\nLet's peek behind the scenes and see what our `TodoStore` librarian (`Todos`) does when it receives the `add()` instruction.\n\n#### Step-by-Step Flow\n\nWhen the `Application Controller` tells the `TodoStore` to `add` a new todo item (like \"Buy milk\"):\n\n1.  The `TodoStore` gets the title (\"Buy milk\").\n2.  It creates a complete \"todo item\" object. This isn't just the title; it also includes `completed: false` (because it's a new task, not yet done) and a unique `id` (like a library catalog number) to identify it later.\n3.  It adds this new, complete todo item object to its internal list of all todo items.\n4.  Crucially, it then saves this entire updated list to the browser's local storage. This is like writing down the new task in a special notebook so it's not lost if you close the browser.\n5.  Finally, it sends out a \"save\" notification. This is how the `TodoStore` tells the [Application Controller](01_application_controller.md) (and anyone else listening) that something has changed and the screen might need to be updated.\n\nHere's a simple diagram to visualize this process:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant AppController as Application Controller\n    participant TodoStore as TodoStore\n    participant BrowserLS as Browser Local Storage\n\n    User->>AppController: Types \"Buy milk\" & presses Enter\n    AppController->>TodoStore: add({ title: \"Buy milk\" })\n    TodoStore->>TodoStore: Creates todo item: { id: \"...\", title: \"Buy milk\", completed: false }\n    TodoStore->>TodoStore: Adds new item to its internal list\n    TodoStore->>BrowserLS: Saves updated list of todos\n    BrowserLS-->>TodoStore: (Data saved successfully)\n    TodoStore-->>AppController: Notifies \"save\" event\n    AppController->>AppController: Re-renders the list on the screen\n```\n\n#### The Code That Makes it Happen (`js/store.js`)\n\nLet's look at the `js/store.js` file, which contains the `TodoStore`'s blueprint.\n\nFirst, the `TodoStore` is set up to be able to send notifications. It does this by extending `EventTarget`:\n\n```javascript\n// From js/store.js\nexport const TodoStore = class extends EventTarget {\n    constructor(localStorageKey) {\n        super(); // This gives our store the ability to send and receive events\n        this.localStorageKey = localStorageKey; // The name for our save file\n        this._readStorage(); // Load any existing todos when the store starts\n        // ... other getter methods for reading todos ...\n    }\n    // ... other methods ...\n};\n```\n\n*   `extends EventTarget`: This is a built-in browser feature that allows objects to \"dispatch\" (send) and \"listen\" for custom events, just like how a button can dispatch a \"click\" event. This is how `TodoStore` tells the [Application Controller](01_application_controller.md) when data changes.\n*   `localStorageKey`: This is the unique name `TodoStore` uses to save its data in the browser's local storage. You'll learn more about this in [Local Storage Persistence](03_local_storage_persistence.md).\n*   `_readStorage()`: This method is called right away to load any existing tasks from local storage when the application starts.\n\nNext, let's examine the `add` method itself:\n\n```javascript\n// From js/store.js\nadd({ title }) {\n    this.todos.push({ // Add the new todo to our internal list\n        title,\n        completed: false, // New tasks are not completed by default\n        id: \"id_\" + Date.now(), // Give it a unique ID\n    });\n    this._save(); // Don't forget to save our changes!\n}\n```\n\n*   `this.todos.push(...)`: `this.todos` is the `TodoStore`'s internal array (list) that holds all the todo items. `push()` adds a new item to the end of this list.\n*   `id: \"id_\" + Date.now()`: This creates a simple, unique ID for each todo item using the current time (`Date.now()`). This ID helps us find and update specific tasks later.\n*   `this._save()`: After adding the new task, we immediately call `_save()` to make sure the change is stored permanently.\n\nAnd finally, the `_save()` method that handles persistence and notification:\n\n```javascript\n// From js/store.js\n_save() {\n    window.localStorage.setItem( // Save the list in the browser's local storage\n        this.localStorageKey,\n        JSON.stringify(this.todos) // Convert our list to a text format\n    );\n    this.dispatchEvent(new CustomEvent(\"save\")); // Tell everyone that we saved!\n}\n```\n\n*   `window.localStorage.setItem(...)`: This is the magic that saves your data in the browser. You'll learn all about this in [Local Storage Persistence](03_local_storage_persistence.md).\n*   `JSON.stringify(this.todos)`: Our list of todos (`this.todos`) is an array of JavaScript objects. Local storage can only store text, so `JSON.stringify` converts our objects into a single string (text) that can be saved.\n*   `this.dispatchEvent(new CustomEvent(\"save\"))`: This is the \"notification\" step! It creates a new custom event named \"save\" and sends it out. The [Application Controller](01_application_controller.md) listens for this event, and when it hears it, it knows to re-render the list of todos on the screen.\n\n### Other Important TodoStore Operations\n\nBeyond `add()`, the `TodoStore` provides many other useful methods to manage your tasks, all following a similar pattern: they change the `this.todos` list and then call `_save()` to persist the changes and notify listeners.\n\n*   `remove({ id })`: Deletes a todo item based on its ID.\n*   `toggle({ id })`: Flips the `completed` status of a todo item (e.g., from not done to done).\n*   `update(todo)`: Changes the details of an existing todo item.\n*   `clearCompleted()`: Removes all todo items that are marked as completed.\n*   `toggleAll()`: Marks all active todos as completed, or all completed todos as active.\n*   `get(id)`: Fetches a single todo item by its ID (doesn't change data).\n*   `all(filter)`: Returns a list of todo items, optionally filtered by their status (all, active, or completed).\n\nThese methods make the `TodoStore` a powerful and easy-to-use manager for all your tasks, abstracting away the complexities of data handling.\n\n### Conclusion\n\nThe `TodoStore` is like the reliable librarian of our application. It's solely responsible for managing our collection of todo items, handling all the adding, removing, updating, and filtering. It also plays a vital role in data persistence by saving our tasks to local storage and informing the rest of the application about any changes.\n\nUnderstanding the `TodoStore` is crucial because it's where all our application's data lives. In the next chapter, we'll dive deeper into how this data is actually saved and loaded, uncovering the secrets of [Local Storage Persistence](03_local_storage_persistence.md).",
      "# Chapter 3: Local Storage Persistence\n\nWelcome back! In our last chapter, we met the [TodoStore](02_todostore.md), our application's helpful librarian who keeps track of all our to-do items. The [TodoStore](02_todostore.md) knows how to add, remove, and update tasks, but there's a big question: what happens to our tasks if we close the browser tab or shut down our computer? Do they just disappear forever?\n\nThat's where **Local Storage Persistence** comes in!\n\n### The Problem: Forgetting Tasks\n\nImagine you're diligently adding your tasks to our to-do app: \"Buy groceries,\" \"Call Mom,\" \"Finish Chapter 3 tutorial.\" You feel productive! But then, you accidentally close your browser. Or maybe your computer restarts. When you open the app again, you'd be pretty upset if all your tasks were gone, right?\n\nWebsites, by default, are a bit forgetful. They usually lose all their information as soon as you close the tab. This is where **Local Storage Persistence** saves the day!\n\n### The Solution: A Persistent Notebook\n\n**Local Storage Persistence** is like a special, persistent notebook that our application keeps inside your browser. This notebook remembers your tasks even after you close the browser and open it again. It makes sure your hard work isn't lost.\n\nIt's also super clever! If you open our to-do app in two different browser tabs at the same time, and you add a task in one tab, this \"notebook\" system will make sure the other tab instantly knows about the new task too. It keeps everything synchronized!\n\n### How Our App Uses This \"Notebook\"\n\nOur [TodoStore](02_todostore.md) (the librarian) works closely with **Local Storage Persistence** (the persistent notebook).\n\nWhen the [TodoStore](02_todostore.md) first starts, it asks the notebook: \"Hey, do you have any tasks saved from before?\"\nWhen you add, remove, or change a task, the [TodoStore](02_todostore.md) tells the notebook: \"Please write down this updated list of tasks!\"\n\nLet's look at how the [TodoStore](02_todostore.md) connects to this notebook.\n\n#### 1. Giving the Notebook a Name\n\nWhen we create our [TodoStore](02_todostore.md), we give it a unique name (a `localStorageKey`). This is like putting a label on our notebook so we don't mix up our to-do list with other websites' saved data.\n\n```javascript\n// From: js/store.js\nexport const TodoStore = class extends EventTarget {\n\tconstructor(localStorageKey) {\n\t\tsuper();\n\t\tthis.localStorageKey = localStorageKey; // This is our notebook's name!\n\t\tthis._readStorage(); // Read tasks from the notebook when we start\n\t\t// ... more code ...\n\t}\n\t// ... more methods ...\n};\n```\n\nHere, `localStorageKey` is just a string, like `\"my-todo-app-tasks\"`. It tells the browser where to find *our specific* list of tasks.\n\n#### 2. Reading Tasks from the Notebook\n\nThe `_readStorage()` method is responsible for opening our persistent notebook and reading all the tasks written inside it.\n\n```javascript\n// From: js/store.js\n\t// ... inside TodoStore class ...\n\t_readStorage() {\n\t\t// 1. Ask the browser's local storage for items using our key\n\t\tconst storedTodos = window.localStorage.getItem(this.localStorageKey);\n\t\t// 2. If there's nothing, start with an empty list.\n\t\t// 3. If there are items, they are text, so convert them back to a list of tasks.\n\t\tthis.todos = JSON.parse(storedTodos || \"[]\");\n\t}\n\t// ... more methods ...\n```\n\n**What's happening here?**\n\n*   `window.localStorage.getItem(this.localStorageKey)`: This is how we ask the browser's local storage for the data associated with our notebook's name. It gives us back a string of text.\n*   `JSON.parse(...)`: Local storage can only store text. Our tasks are objects (with properties like `title`, `completed`, `id`). `JSON.parse()` is like a translator that converts the saved text back into usable JavaScript objects. If there's no data saved yet (`storedTodos` is empty), we just give it `[]` (an empty list) to start with.\n\n#### 3. Writing Tasks to the Notebook\n\nWhen we add, remove, or change a task, our [TodoStore](02_todostore.md) calls the `_save()` method. This method writes the current list of tasks into our persistent notebook.\n\n```javascript\n// From: js/store.js\n\t// ... inside TodoStore class ...\n\t_save() {\n\t\t// 1. Convert our list of tasks (objects) into a single string of text.\n\t\tconst todosAsString = JSON.stringify(this.todos);\n\t\t// 2. Ask the browser's local storage to save this text under our key.\n\t\twindow.localStorage.setItem(this.localStorageKey, todosAsString);\n\t\t// 3. Tell other parts of the app that something was saved.\n\t\tthis.dispatchEvent(new CustomEvent(\"save\"));\n\t}\n\t// ... more methods ...\n```\n\n**What's happening here?**\n\n*   `JSON.stringify(this.todos)`: This is the opposite of `JSON.parse()`. It takes our list of JavaScript task objects and converts them into a single string of text that local storage can understand and save.\n*   `window.localStorage.setItem(this.localStorageKey, todosAsString)`: This tells the browser's local storage to take our `todosAsString` and store it under our notebook's name (`this.localStorageKey`).\n*   `this.dispatchEvent(new CustomEvent(\"save\"))`: After saving, the [TodoStore](02_todostore.md) sends out a small signal (an event) saying, \"Hey, I just saved something!\" Other parts of our app, like the [Application Controller](01_application_controller.md), might listen for this signal to update the display.\n\nYou can see how `_save()` is called whenever tasks are changed:\n\n```javascript\n// From: js/store.js\n\t// ... inside TodoStore class ...\n\tadd({ title }) {\n\t\tthis.todos.push({\n\t\t\ttitle,\n\t\t\tcompleted: false,\n\t\t\tid: \"id_\" + Date.now(),\n\t\t});\n\t\tthis._save(); // <-- Tasks changed, so save them!\n\t}\n\tremove({ id }) {\n\t\tthis.todos = this.todos.filter((todo) => todo.id !== id);\n\t\tthis._save(); // <-- Tasks changed, so save them!\n\t}\n\t// ... many other methods also call _save() ...\n```\n\n### Syncing Across Multiple Tabs\n\nRemember how we said our persistent notebook is super clever and can synchronize between tabs? This is a really neat feature of browser local storage!\n\nWhen data is changed in local storage by one browser tab, the browser automatically tells *all other open tabs* that are using the same `localStorageKey` that something has changed. Our app listens for this notification.\n\n```javascript\n// From: js/store.js\nexport const TodoStore = class extends EventTarget {\n\tconstructor(localStorageKey) {\n\t\tsuper();\n\t\tthis.localStorageKey = localStorageKey;\n\t\tthis._readStorage();\n\t\t// Listen for changes from other browser windows/tabs!\n\t\twindow.addEventListener(\n\t\t\t\"storage\",\n\t\t\t() => {\n\t\t\t\tthis._readStorage(); // Read the latest tasks from the notebook\n\t\t\t\tthis._save(); // Re-save (this also dispatches a 'save' event)\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t\t// ... more code ...\n\t}\n\t// ... more methods ...\n};\n```\n\n**What's happening here?**\n\n*   `window.addEventListener(\"storage\", ...)`: This line sets up a \"listener.\" It's like telling our app, \"Keep an ear out for any 'storage' events!\"\n*   When a `storage` event happens (meaning another tab changed our `localStorageKey` data), our app immediately calls `_readStorage()` to fetch the updated task list. Then it calls `_save()` to make sure its own state is also saved and to trigger the `save` event, notifying the rest of the application (like the UI) to update.\n\nThis ensures that if you have your to-do list open in Chrome and Firefox, or two Chrome tabs, adding a task in one will make it appear in the others almost instantly!\n\nHere's a quick flow of how cross-tab sync works:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant TabA as App Tab A\n    participant BrowserLocalStorage as Browser Local Storage\n    participant TabB as App Tab B\n\n    User->>TabA: Adds \"Buy Milk\"\n    TabA->>BrowserLocalStorage: Saves \"Buy Milk\" list\n    BrowserLocalStorage-->>TabB: Notifies: \"Hey, data for 'my-todo-app-tasks' changed!\"\n    TabB->>TabB: Receives \"storage\" event\n    TabB->>BrowserLocalStorage: Reads updated list (\"Buy Milk\")\n    TabB->>TabB: Updates its own tasks and UI\n```\n\n### Conclusion\n\nYou've learned that **Local Storage Persistence** is our application's memory. It uses the browser's `localStorage` to save our tasks (as text using `JSON.stringify`) so they stick around even after the browser closes. It also cleverly listens for changes from other tabs (`window.addEventListener(\"storage\")`) to keep everything perfectly synchronized.\n\nThanks to this mechanism, our [TodoStore](02_todostore.md) always has the most up-to-date list of tasks, whether they were added moments ago or weeks ago!\n\nNext, we'll dive into how each individual todo item is drawn on the screen, in [Chapter 4: Todo Item Renderer](04_todo_item_renderer.md).",
      "# Chapter 4: Todo Item Renderer\n\nIn the last chapter, we learned about [Local Storage Persistence](03_local_storage_persistence.md), which is how our application keeps your todo list safe even if you close your browser. It's like having a special notebook that remembers everything. But how do these saved todos actually *appear* on your screen? How do we turn plain data like \"Buy milk\" into a visible, clickable item on a web page?\n\nThat's where the **Todo Item Renderer** comes in!\n\n### What Does the Todo Item Renderer Do?\n\nImagine you have a recipe for a cake (this is like your todo item's data: \"Buy milk\", \"completed: false\"). The browser doesn't understand recipes; it needs a real, baked cake to display! The **Todo Item Renderer** is like the chef who follows that recipe (your todo data) and bakes the actual cake (an HTML element) that you can see and interact with on the page.\n\nIts main job is to:\n*   Take a single todo item's information (like its ID, text, and whether it's done).\n*   Turn that information into a piece of HTML code (like a list item `<li>` element).\n*   Make sure this HTML looks correct, reflecting if the item is completed, or if it's currently being edited.\n\nIt's the blueprint and construction crew for each individual task you see on your list.\n\n### Our Goal: Displaying a Single Todo\n\nLet's say our [TodoStore](02_todostore.md) gives us this piece of data for a todo item:\n\n```javascript\n// This is just data, not visible on the screen yet!\nconst myTodoData = {\n    id: \"abc-123\",\n    title: \"Walk the dog\",\n    completed: false\n};\n```\n\nOur goal for the Todo Item Renderer is to turn `myTodoData` into something that looks like this on the webpage:\n\n```html\n<!-- This is what we want to create and show -->\n<li data-id=\"abc-123\">\n    <div class=\"view\">\n        <input class=\"toggle\" type=\"checkbox\">\n        <label>Walk the dog</label>\n        <button class=\"destroy\"></button>\n    </div>\n    <input class=\"edit\">\n</li>\n```\n\nThis HTML `<li>` (list item) has everything we need: a checkbox to mark it done, a label to show the text, a button to delete it, and even a hidden input box for editing.\n\n### How to Use the Todo Item Renderer\n\nIn our application, the `App.createTodoItem()` function acts as our Todo Item Renderer. The [Application Controller](01_application_controller.md) calls this function whenever it needs to show a todo item on the screen.\n\nIt's used like this:\n\n```javascript\n// File: js/app.js (simplified view)\n\n// Imagine 'todo' is our data: { id: \"abc-123\", title: \"Walk the dog\", completed: false }\nconst myHtmlElement = App.createTodoItem(todo);\n\n// After this, 'myHtmlElement' holds the actual <li> HTML element!\n// It's ready to be added to the list on the page.\n```\n\nThe `App.createTodoItem()` function expects a `todo` object (like `myTodoData` above) and returns a fully built HTML `<li>` element.\n\n### Inside the Todo Item Renderer: The \"Construction Crew\" at Work\n\nLet's peek under the hood of `App.createTodoItem()` to see how it builds the HTML.\n\n#### Step-by-Step Walkthrough\n\n1.  **Start with a Blank Slate**: The renderer first creates an empty `<li>` (list item) element, like preparing a new blank piece of paper.\n2.  **Give it an ID**: It then attaches a special `data-id` to this `<li>` that matches the todo item's unique ID. This is like writing the unique serial number on our piece of paper.\n3.  **Check for \"Completed\"**: If the todo item is marked as `completed` (e.g., `completed: true`), the renderer adds a special CSS class (like `completed`) to the `<li>`. This class usually makes the item look different, like showing a strikethrough text.\n4.  **Insert the Standard Parts**: It then inserts the basic \"template\" HTML structure inside the `<li>`. This includes the `div` for viewing, the checkbox, the label, the delete button, and the edit input field. This is like adding the pre-made parts of our cake (the layers, frosting, decorations).\n5.  **Fill in the Specifics**: Finally, it takes the `title` from our todo data (\"Walk the dog\") and puts it into the `<label>` and the edit `<input>` field. This is like adding the specific flavor or topping to our cake.\n6.  **Hand it Over**: The completed `<li>` HTML element is then returned, ready to be displayed.\n\n```mermaid\nsequenceDiagram\n    participant AC as Application Controller\n    participant TIR as Todo Item Renderer\n    participant DOM as Browser's Document Object Model\n\n    AC->>TIR: Call createTodoItem(todoData)\n    TIR->>DOM: Create new <li> element\n    TIR->>DOM: Set data-id, add 'completed' class (if needed)\n    TIR->>DOM: Insert inner HTML structure (checkbox, label, buttons)\n    TIR->>DOM: Fill label text & edit input value from todoData\n    TIR-->>AC: Return fully built <li> element\n```\n\n#### Code Deep Dive\n\nLet's look at the `createTodoItem` function in `js/app.js`.\n\nFirst, it creates a new list item and gives it a unique ID:\n\n```javascript\n// File: js/app.js\n// ... inside the App object ...\n\n\tcreateTodoItem(todo) {\n\t\tconst li = document.createElement(\"li\"); // Create an empty <li> tag\n\t\tli.dataset.id = todo.id;              // Store the todo's unique ID on the <li>\n\t\t// ... more code to build the <li> ...\n\t\treturn li; // Eventually return the complete <li>\n\t},\n```\nHere, `document.createElement(\"li\")` is how JavaScript asks the browser to make a new, blank list item HTML tag. `li.dataset.id = todo.id;` then attaches a special identifier (`data-id`) to this `<li>`, making it easy to find this specific todo item later.\n\nNext, it checks if the todo is completed:\n\n```javascript\n// File: js/app.js\n// ... inside createTodoItem(todo) ...\n\n\t\tif (todo.completed) {\n\t\t\tli.classList.add(\"completed\"); // Add 'completed' class if todo is done\n\t\t}\n\t\t// ... more code ...\n```\nIf `todo.completed` is `true`, it adds the `completed` class to our `<li>`. This class is used by CSS (Cascading Style Sheets) to style the completed tasks differently (like adding a line through them).\n\nThen, it inserts the main HTML structure:\n\n```javascript\n// File: js/app.js\nimport { insertHTML } from \"./helpers.js\"; // Used to easily add HTML content\n\n// ... inside createTodoItem(todo) ...\n\n\t\tinsertHTML(\n\t\t\tli, // Insert this HTML inside our <li> element\n\t\t\t`\n\t\t\t<div class=\"view\">\n\t\t\t\t<input data-todo=\"toggle\" class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\n\t\t\t\t<label data-todo=\"label\"></label>\n\t\t\t\t<button class=\"destroy\" data-todo=\"destroy\"></button>\n\t\t\t</div>\n\t\t\t<input class=\"edit\" data-todo=\"edit\">\n\t\t`\n\t\t);\n\t\t// ... more code ...\n```\nThis is a big step! The `insertHTML` function (which we'll learn more about in [DOM Helpers](05_dom_helpers.md)) is used to place a standard set of HTML elements inside our `<li>`. Notice the `<input type=\"checkbox\">` also checks if `todo.completed` is true and automatically adds `checked` to the checkbox if it is. This ensures the checkbox reflects the todo's state.\n\nFinally, it fills in the specific text and returns the result:\n\n```javascript\n// File: js/app.js\n// ... inside createTodoItem(todo) ...\n\n\t\tli.querySelector('[data-todo=\"label\"]').textContent = todo.title;\n\t\tli.querySelector('[data-todo=\"edit\"]').value = todo.title;\n\t\treturn li; // Hand back the complete HTML <li> element\n\t}, // End of createTodoItem function\n```\nHere, `li.querySelector('[data-todo=\"label\"]')` finds the `<label>` inside our `<li>` and sets its text content to `todo.title` (e.g., \"Walk the dog\"). It does the same for the edit input field. Now, the `<li>` is fully assembled and contains all the necessary data and structure! It's returned to whoever called `createTodoItem`.\n\n#### How `App.render()` Uses It\n\nThe `App.render()` function in our [Application Controller](01_application_controller.md) is responsible for updating the entire list of todos on the screen. It uses `createTodoItem` like this:\n\n```javascript\n// File: js/app.js\n// ... inside App.render() ...\n\n\t\t// Get all todos, then for EACH todo, create an HTML item\n\t\tApp.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\n\t\t// ... more rendering logic ...\n\t},\n```\nThis line is powerful!\n1.  `Todos.all(App.filter)` asks the [TodoStore](02_todostore.md) for all the todo items that should currently be displayed (e.g., all, active, or completed).\n2.  `.map((todo) => App.createTodoItem(todo))` then goes through *each* of those todo items and calls `App.createTodoItem()` on it. This creates a brand new HTML `<li>` element for *every* todo item.\n3.  `App.$.list.replaceChildren(...)` finally takes all these newly created HTML `<li>` elements and puts them into the main todo list (`App.$.list`), replacing any old items that were there before.\n\nThis means that every time something changes in our todo list (a new item is added, one is completed, etc.), the `render()` function rebuilds *all* the visible todo items using our **Todo Item Renderer** to make sure the screen is always up-to-date!\n\n### Conclusion\n\nThe **Todo Item Renderer** is a crucial piece of our application. It acts as the bridge between the plain data stored in our [TodoStore](02_todostore.md) and the visible, interactive HTML elements on our webpage. By taking a `todo` object and transforming it into a properly structured and styled `<li>` element, it ensures that your tasks are always presented accurately.\n\nYou've seen functions like `insertHTML` being used to make this process easier. In the next chapter, we'll dive deeper into these helpful tools, exploring the [DOM Helpers](05_dom_helpers.md) that simplify interacting with and building parts of our web page.\n\n[Next Chapter: DOM Helpers](05_dom_helpers.md)",
      "# Chapter 5: DOM Helpers\n\nWelcome back! In our last chapter, [Todo Item Renderer](04_todo_item_renderer.md), we learned how to create the actual HTML `<li>` structure for a single todo item. It was like designing a blueprint and constructing a single brick for our wall. But how do we actually *put* these newly built bricks into our main todo list wall in the browser? And how do we update existing parts of that wall, like changing a number display?\n\nThis is where **DOM Helpers** come in.\n\n### What Problem Do DOM Helpers Solve?\n\nImagine you're building with LEGOs. You have individual LEGO bricks (your HTML elements), and you want to connect them to build a structure. The \"DOM\" (which stands for Document Object Model) is essentially how your web browser sees and organizes all the HTML elements on a page. Think of it as a big tree structure where every part of your web page (like a paragraph, a button, or an entire list) is a \"node\" or a \"branch.\"\n\nDirectly working with this \"DOM tree\" using plain JavaScript can sometimes feel a bit repetitive or clunky, especially for common tasks like:\n\n1.  **Adding new HTML** into an existing element (e.g., adding a new todo item to our `<ul>` list).\n2.  **Replacing content** inside an element (e.g., updating the \"X items left\" message).\n\nOur **DOM Helpers** are like a small set of specialized tools, such as a mini-crane or a quick-release lever, that make these common tasks much simpler and faster. Instead of writing several lines of code every time, we use a single, friendly helper function.\n\nLet's look at our two main helper tools: `insertHTML` and `replaceHTML`.\n\n### Our Specialized Tools: `insertHTML` and `replaceHTML`\n\nIn our project, we have two key **DOM Helper** functions:\n\n1.  **`insertHTML(element, htmlString)`**: This tool takes an HTML element (where you want to put something) and a string of HTML code (what you want to put there), and then places that HTML *inside* the element, right at the beginning.\n    *   **Analogy**: It's like having a special tool that lets you quickly add a new LEGO piece *inside* another larger LEGO structure, always at the top.\n\n2.  **`replaceHTML(element, htmlString)`**: This tool is a bit more powerful. It first *clears out* everything currently inside an HTML element, and then `insertHTML` to put new HTML content there.\n    *   **Analogy**: This is like using a tool that first empties a LEGO box completely, and then carefully places new LEGO pieces inside.\n\nThese two helpers are found in our `js/helpers.js` file and are imported into our main application logic:\n\n```javascript\n// From js/app.js\nimport { delegate, getURLHash, insertHTML, replaceHTML } from \"./helpers.js\";\n// ... (rest of the file)\n```\n\n### How We Use DOM Helpers\n\nLet's see how our application uses these handy helpers.\n\n#### 1. Adding New Todo Items with `insertHTML`\n\nWhen we create a new todo item (as we saw in [Todo Item Renderer](04_todo_item_renderer.md)), we need to place its HTML structure into the main `<ul>` list where all todos are displayed.\n\nOur `App.createTodoItem` function creates an `<li>` element and then uses `insertHTML` to fill it with the internal `<div>`, `<input>`, and `<button>` elements.\n\n```javascript\n// Simplified excerpt from App.createTodoItem in js/app.js\ncreateTodoItem(todo) {\n    const li = document.createElement(\"li\"); // Create the <li> element\n    // ... (set other properties like li.dataset.id, li.classList)\n\n    insertHTML(\n        li, // The target element: our new <li>\n        `\n        <div class=\"view\">\n            <input data-todo=\"toggle\" class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\n            <label data-todo=\"label\"></label>\n            <button class=\"destroy\" data-todo=\"destroy\"></button>\n        </div>\n        <input class=\"edit\" data-todo=\"edit\">\n        ` // The HTML string to insert inside <li>\n    );\n    // ... (set textContent and value for label/input)\n    return li;\n}\n```\n\n**Explanation**:\nHere, `insertHTML` takes the `li` element we just created and injects the provided HTML string right at the beginning of its content. This quickly builds the internal structure of our todo item without needing to create each `div`, `input`, `label`, and `button` element one by one using `document.createElement`.\n\n#### 2. Updating the Todo Count with `replaceHTML`\n\nAnother common task is updating the text that tells us \"X items left.\" This text often changes as we add, complete, or remove todo items. Instead of carefully finding the old text and changing it, we use `replaceHTML` to simply wipe out the old count and put in the new one.\n\n```javascript\n// Simplified excerpt from App.$.displayCount in js/app.js\ndisplayCount(count) {\n    replaceHTML(\n        document.querySelector('[data-todo=\"count\"]'), // The element showing the count\n        `\n        <strong>${count}</strong>\n        ${count === 1 ? \"item\" : \"items\"} left\n        ` // The new HTML string to display\n    );\n}\n```\n\n**Explanation**:\nIn this example, `replaceHTML` finds the element responsible for showing the todo count (using `document.querySelector('[data-todo=\"count\"]')`). It then completely clears out any HTML that was inside that element and replaces it with our new `<strong>` and text, correctly saying \"1 item left\" or \"2 items left.\"\n\n### Under the Hood: How DOM Helpers Work\n\nLet's peek behind the curtain to see how `insertHTML` and `replaceHTML` actually do their job. They rely on some built-in browser JavaScript features.\n\n#### The `replaceHTML` Flow\n\nWhen `App.$.displayCount` (from our [Application Controller](01_application_controller.md)) calls `replaceHTML`, here's a simplified sequence of events:\n\n```mermaid\nsequenceDiagram\n    participant App as Application Controller\n    participant D_H as DOM Helpers\n    participant Browser as Browser's JavaScript\n\n    App->>D_H: replaceHTML(element, newHTML)\n    D_H->>Browser: element.replaceChildren()\n    Note over Browser: Clears ALL existing content inside 'element'\n    D_H->>D_H: insertHTML(element, newHTML)\n    D_H->>Browser: element.insertAdjacentHTML(\"afterbegin\", newHTML)\n    Note over Browser: Puts newHTML at the beginning of 'element'\n    Browser-->>D_H: HTML updated\n    D_H-->>App: Task finished\n```\n\nAs you can see, `replaceHTML` doesn't do all the work itself. It uses another helper, `insertHTML`, after first clearing the target element.\n\n#### `insertHTML` Implementation\n\nLet's look at the actual code for `insertHTML` from `js/helpers.js`:\n\n```javascript\n// From js/helpers.js\nexport const insertHTML = (el, html) => el.insertAdjacentHTML(\"afterbegin\", html);\n```\n\n**Explanation**:\nThis is a very direct helper! It uses a built-in browser function called `insertAdjacentHTML`. This function is powerful because it lets you inject HTML strings into the DOM at specific positions relative to an element.\n\n*   `el`: This is the HTML element where you want to add content.\n*   `\"afterbegin\"`: This is a special keyword that tells the browser to insert the new `html` string *inside* the `el`, right at the very beginning of its children. Other options exist, but `afterbegin` is what `insertHTML` uses.\n*   `html`: This is the string of HTML code you want to add.\n\nSo, `insertHTML` simply wraps `insertAdjacentHTML(\"afterbegin\", ...)` to provide a cleaner, more readable way to add content to the beginning of an element.\n\n#### `replaceHTML` Implementation\n\nNow for `replaceHTML` from `js/helpers.js`:\n\n```javascript\n// From js/helpers.js\nexport const replaceHTML = (el, html) => {\n    el.replaceChildren(); // Step 1: Clear everything inside 'el'\n    insertHTML(el, html);  // Step 2: Use our 'insertHTML' helper to add new content\n};\n```\n\n**Explanation**:\nThis helper has two steps:\n\n1.  `el.replaceChildren()`: This is another very useful built-in browser function. When you call it on an element, it completely removes *all* of that element's children (anything nested inside it). It's like hitting the \"clear all contents\" button for that part of your web page.\n2.  `insertHTML(el, html)`: After clearing the old content, `replaceHTML` then calls our `insertHTML` helper (which we just looked at) to put the `html` string inside the now-empty `el`.\n\nBy combining these two steps, `replaceHTML` gives us a simple way to completely refresh an element's content.\n\n### Conclusion\n\nIn this chapter, we've explored **DOM Helpers**, a collection of utility functions that act like specialized tools for common DOM manipulation tasks. We learned about `insertHTML` for adding new HTML content and `replaceHTML` for clearing and replacing existing content. These helpers make our code cleaner, easier to understand, and prevent us from writing repetitive DOM operations.\n\nWe saw how they are used by our [Application Controller](01_application_controller.md) and how they simplify the work of placing the HTML created by our [Todo Item Renderer](04_todo_item_renderer.md).\n\nNext up, in [UI Event Delegation](06_ui_event_delegation.md), we'll discover a smart way to handle user interactions like clicks and double-clicks on our todo items, especially when those items are constantly being added and removed!\n\n[Next Chapter: UI Event Delegation](06_ui_event_delegation.md)",
      "# Chapter 6: UI Event Delegation\n\nWelcome back! In our last chapter, [DOM Helpers](05_dom_helpers.md), we learned about handy tools for manipulating parts of our web page. Now, we're going to tackle how our application listens to what you, the user, are doing on those elements – like clicking buttons or typing. This is where **UI Event Delegation** comes in, making our application smarter and more efficient.\n\n### What's the Problem with Lots of Buttons?\n\nImagine our Todo app with a long list of items. Each todo item usually has a \"delete\" button, a checkbox to mark it as complete, and maybe a label you can double-click to edit.\n\nIf we have 100 todo items, that's 100 delete buttons, 100 checkboxes, and 100 labels. A basic way to make them work would be to attach a separate \"click\" listener to *each* and *every* one of these elements.\n\n```javascript\n// A *bad* example for illustration!\n// Don't do this for many items.\nconst deleteButton1 = document.getElementById('delete-todo-1');\ndeleteButton1.addEventListener('click', () => {\n    // Delete todo 1\n});\n\nconst deleteButton2 = document.getElementById('delete-todo-2');\ndeleteButton2.addEventListener('click', () => {\n    // Delete todo 2\n});\n// ... and so on for 100 buttons!\n```\n\nThis approach has a couple of big problems:\n\n1.  **Too many listeners**: Attaching hundreds or even thousands of event listeners can slow down your web page and use a lot of memory. It's like having a separate phone line for every single person in a large office building – very inefficient!\n2.  **New elements**: What happens when you add a *new* todo item to the list? Its delete button won't have a listener, so it won't work! We'd have to remember to add a new listener every time we create a new todo. This is tedious and error-prone.\n\nThis is exactly the problem that **UI Event Delegation** solves!\n\n### The Receptionist Analogy\n\nThink of UI Event Delegation like a **receptionist** in a big office building.\n\n*   Instead of every person in the office having their own phone line (which is like each button having its own event listener), there's **one main receptionist** who answers all incoming calls (this is the *parent element* with one event listener).\n*   When a call comes in, the receptionist asks, \"Who are you trying to reach?\" (this is checking `e.target`).\n*   Then, they **direct the call** to the correct person or department (this is our event handler function that runs specific code based on what was clicked).\n\nSo, in our Todo app, instead of listening to *each individual todo item's button*, we can listen to the **main list** where all todo items live. When something inside the list is clicked, the main list's listener figures out *what* was clicked and *which* todo item it belongs to.\n\n### How We Use Event Delegation in Our App\n\nLet's look at how our `Application Controller` ([Chapter 1](01_application_controller.md)) uses event delegation to handle interactions with todo items. The key magic happens in the `App.bindTodoEvents()` function, which uses a special helper function called `App.todoEvent()`.\n\nFirst, let's see where the `delegate` helper function comes from:\n\n```javascript\n// File: js/app.js (excerpt)\nimport { delegate, /* ...other helpers */ } from \"./helpers.js\";\n// ...\n```\n\nOur `delegate` helper is imported from `js/helpers.js`. It's the core of our event delegation strategy.\n\nNext, the `App.bindTodoEvents()` method sets up all the delegated listeners for our todo list:\n\n```javascript\n// File: js/app.js (excerpt)\n// ...\n\tbindTodoEvents() {\n\t\tApp.todoEvent(\"click\", '[data-todo=\"destroy\"]', (todo) => Todos.remove(todo));\n\t\tApp.todoEvent(\"click\", '[data-todo=\"toggle\"]', (todo) => Todos.toggle(todo));\n\t\tApp.todoEvent(\"dblclick\", '[data-todo=\"label\"]', (_, $li) => {\n\t\t\t$li.classList.add(\"editing\");\n\t\t\t$li.querySelector('[data-todo=\"edit\"]').focus();\n\t\t});\n\t\t// ... more todo events\n\t},\n// ...\n```\n\nNotice how `App.bindTodoEvents` calls `App.todoEvent` multiple times. Each call tells our app to listen for a specific action (like \"click\" or \"dblclick\") on specific kinds of elements (like `[data-todo=\"destroy\"]` buttons or `[data-todo=\"label\"]` elements) *inside* our main todo list.\n\nLet's break down `App.todoEvent()`:\n\n```javascript\n// File: js/app.js (excerpt)\n// ...\n\ttodoEvent(event, selector, handler) {\n\t\tdelegate(App.$.list, selector, event, (e) => {\n\t\t\tlet $el = e.target.closest(\"[data-id]\");\n\t\t\thandler(Todos.get($el.dataset.id), $el, e);\n\t\t});\n\t},\n// ...\n```\n\nThis `todoEvent` method is a special wrapper that makes it easier to use the `delegate` helper.\n\nHere's what each part does:\n\n*   `App.$.list`: This is the big **parent element** (our \"receptionist\"). It's the `<ul>` element that holds all our individual `<li>` todo items. We want to attach *one* listener to this element.\n*   `selector`: This is like saying, \"I'm interested in calls for the 'Delete Button Department' (`[data-todo=\"destroy\"]`) or the 'Edit Label Department' (`[data-todo=\"label\"]`).\" It's a CSS selector that matches the *child elements* we care about.\n*   `event`: This is the type of user interaction, like a `\"click\"`, `\"dblclick\"`, or `\"keyup\"`.\n*   `handler`: This is the function that runs when the specific `event` happens on a matching `selector` *inside* the `App.$.list`.\n    *   Inside this handler, `e.target.closest(\"[data-id]\")` helps us find the actual `<li>` element (the specific todo item) that the clicked element belongs to.\n    *   Then, `Todos.get($el.dataset.id)` fetches the correct todo item data from our `TodoStore` ([Chapter 2](02_todostore.md)).\n    *   Finally, the provided `handler` function (like `(todo) => Todos.remove(todo)`) is called with the relevant `todo` item and the HTML element `$el`.\n\nSo, for example, the line:\n\n```javascript\n// Inside App.bindTodoEvents()\nApp.todoEvent(\"click\", '[data-todo=\"destroy\"]', (todo) => Todos.remove(todo));\n```\n\nMeans: \"Attach *one* 'click' listener to the main `App.$.list`. If any click happens *inside* that list, and the clicked element (or one of its parents) matches `[data-todo=\"destroy\"]`, then find the corresponding todo item and tell the `TodoStore` to `remove` it.\"\n\nThis single line effectively handles clicks for *all* delete buttons, even ones that are added to the list later!\n\n### How the `delegate` Helper Works Under the Hood\n\nLet's peek into `js/helpers.js` to see the `delegate` function itself. It's quite simple but powerful!\n\n```javascript\n// File: js/helpers.js (excerpt)\n// ...\nexport const delegate = (el, selector, event, handler) => {\n\tel.addEventListener(event, (e) => {\n\t\tif (e.target.matches(selector)) handler(e, el);\n\t});\n};\n// ...\n```\n\nHere's a step-by-step breakdown of what happens when you click a \"destroy\" button in our todo list:\n\n1.  **Click happens**: You click on a `<button class=\"destroy\" data-todo=\"destroy\"></button>` within a `<li>` in our `App.$.list` (the `<ul>`).\n2.  **Event Bubbling**: The click event starts at the `button` you clicked. Then, it \"bubbles up\" (travels upwards) through its parent elements: first to the `div`, then to the `li`, and eventually to the `App.$.list` (the `ul`).\n3.  **`delegate`'s Listener Catches It**: Because we attached a single `addEventListener` to `App.$.list` using `delegate`, this listener catches *all* click events that bubble up from inside the list.\n4.  **Is it the right element?**: Inside the `delegate` function, `e.target` refers to the *exact element* that was clicked (in our example, the `<button>`).\n    *   The line `if (e.target.matches(selector))` checks if this clicked element (`e.target`) matches the `selector` we passed in (which was `[data-todo=\"destroy\"]`).\n    *   Since you clicked the destroy button, `e.target` *does* match `[data-todo=\"destroy\"]`.\n5.  **Run the `handler`**: Because it matched, our `handler` function (the `(e) => { ... }` function inside `App.todoEvent`) is now executed. This handler then figures out which todo item to remove from the `TodoStore`.\n\nHere's a simplified sequence of events using a Mermaid diagram:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant DeleteButton as Delete Button Element\n    participant TodoItem as Todo Item (LI)\n    participant TodoList as Todo List (UL)\n    participant DelegateHelper as 'delegate' helper\n    participant TodoEventWrapper as 'App.todoEvent' wrapper\n    participant AppController as Application Controller (Todos.remove)\n\n    User->>DeleteButton: Clicks\n    DeleteButton->>TodoItem: Event bubbles up\n    TodoItem->>TodoList: Event bubbles up\n    TodoList->>DelegateHelper: 'delegate' listener fires\n    DelegateHelper->>TodoEventWrapper: Calls internal handler (e.target.matches('[data-todo=\"destroy\"]'))\n    TodoEventWrapper->>AppController: Identifies todo, calls Todos.remove(todo)\n    AppController-->>User: Todo is removed from UI\n```\n\nThis pattern is incredibly useful because it centralizes all event handling for dynamic lists, making your code cleaner and more performant.\n\n### Benefits of UI Event Delegation\n\n*   **Performance**: Only one listener is needed for a whole container, not for each individual item, saving memory and processing power.\n*   **Dynamic Elements**: When new todo items are added to the list (like when you type a new todo), you don't need to manually attach new event listeners to their buttons. The single delegated listener on the parent automatically handles events for them because events from new children will also bubble up.\n*   **Cleaner Code**: Your `Application Controller` ([Chapter 1](01_application_controller.md)) can declare all its event handling logic in one place, making it easier to understand and maintain.\n\n### Conclusion\n\nYou've now mastered UI Event Delegation! We learned that instead of attaching many event listeners to individual elements, we can attach just one listener to a parent element and let it \"delegate\" handling events for its children. This is a crucial technique for building dynamic, efficient web applications.\n\nNext up, we'll look at how our app manages different views of our todos (all, active, completed) using the [View Router](07_view_router.md).",
      "# Chapter 7: View Router\n\nWelcome back! In our [previous chapter on UI Event Delegation](06_ui_event_delegation.md), we learned how to efficiently manage user interactions across many elements in our To-Do list. Now, imagine you have a very long list of tasks. Sometimes you want to see *all* your tasks, sometimes just the *active* ones (those you haven't finished yet), and other times only the *completed* tasks. How can our application let users switch between these different views? This is exactly the problem our **View Router** helps us solve!\n\nThink of the `View Router` like a helpful guide in a big park. The park has different sections: \"All Tasks,\" \"Active Tasks,\" and \"Completed Tasks.\" When you tell your guide which section you want to visit, they take you there and make sure the map shows your current location.\n\n## The Problem: Filtering What You See\n\nCurrently, our To-Do application shows all tasks. But a good To-Do app usually has filter buttons like \"All,\" \"Active,\" and \"Completed.\"\n\nFor example, if a user clicks the \"Active\" button, we want:\n1.  Only to show tasks that are *not* yet completed.\n2.  The \"Active\" button itself to look \"selected\" (e.g., highlighted) so the user knows what they're viewing.\n3.  If the user refreshes the page or shares the link, it should *still* show \"Active\" tasks.\n\nHow can we achieve this without constantly reloading the entire page? This is where the URL hash comes in.\n\n## What is a URL Hash?\n\nYou've probably seen URLs like `https://example.com/page.html#section2`. The part after the `#` symbol is called the \"URL hash\" (or sometimes \"fragment identifier\"). It's traditionally used to jump to a specific part of a web page.\n\nIn modern web applications, we can cleverly use the URL hash to represent the *state* of our application, like which filter is currently active. For our To-Do app:\n*   `#/` (or nothing after `#`) could mean \"All\" tasks.\n*   `#/active` could mean \"Active\" tasks.\n*   `#/completed` could mean \"Completed\" tasks.\n\nWhen you click on filter links like `All`, `Active`, or `Completed` in our app, the URL in your browser's address bar changes (e.g., from `your-app.com` to `your-app.com/#/active`), but the page doesn't reload! This is a perfect way to let users switch views without interrupting their experience.\n\n## How the View Router Works: A Simple Guide\n\nOur `View Router` does a few key things:\n\n1.  **Reads the Map (URL Hash):** It looks at the URL hash to figure out which section of the \"park\" (which filter) the user wants to see.\n2.  **Updates the Internal State:** It remembers this choice in a special variable (`App.filter`).\n3.  **Shows the Right View:** It tells the [TodoStore](02_todostore.md) to provide only the tasks that match the chosen filter (e.g., only active tasks).\n4.  **Highlights the Path:** It visually updates the filter buttons (e.g., \"Active\") to show which one is currently selected.\n5.  **Listens for Changes:** It constantly listens for when the user clicks a different filter button or manually changes the URL hash. When this happens, it repeats steps 1-4.\n\nLet's see this in action.\n\n## Solving the Filter Use Case with Code\n\nFirst, we need a way to easily get the current URL hash.\n\n### 1. Getting the Current Filter from the URL\n\nWe have a small helper function in `js/helpers.js` called `getURLHash` that extracts the filter name from the URL hash.\n\n```javascript\n// From: js/helpers.js\n\nexport const getURLHash = () => document.location.hash.replace(/^#\\//, \"\");\n```\n\n**Explanation:**\n*   `document.location.hash` gives us the part of the URL starting with `#` (e.g., `#/active`).\n*   `.replace(/^#//, \"\")` is a neat trick to remove the `#/` part, leaving just `active` (or `completed`, or an empty string for `all`).\n\nWhen you call `getURLHash()`, it will return:\n*   `\"\"` (empty string) if the URL is `http://localhost:8080/#/` (which we treat as \"all\").\n*   `\"active\"` if the URL is `http://localhost:8080/#/active`.\n*   `\"completed\"` if the URL is `http://localhost:8080/#/completed`.\n\nThis returned value is stored in `App.filter` in our main [Application Controller](01_application_controller.md).\n\n### 2. Listening for Filter Changes\n\nIn our [Application Controller](01_application_controller.md)'s `init()` method, we first set the initial filter when the app loads, and then we tell the browser to let us know if the URL hash ever changes.\n\n```javascript\n// From: js/app.js (inside App.init())\n\nApp.filter = getURLHash(); // 1. Get initial filter on page load\n\nwindow.addEventListener(\"hashchange\", () => {\n    App.filter = getURLHash(); // 2. Get new filter when URL hash changes\n    App.render();              // 3. Re-render the view to show filtered tasks\n});\n```\n\n**Explanation:**\n*   `App.filter = getURLHash();` sets our initial filter. So, if someone opens the app at `http://localhost:8080/#/active`, `App.filter` will immediately become `\"active\"`.\n*   `window.addEventListener(\"hashchange\", ...)` is super important! The browser fires a `hashchange` event whenever the URL hash changes (e.g., if you click a filter button that updates the hash).\n*   Inside this event listener, we again call `getURLHash()` to update `App.filter` with the *new* hash value.\n*   Then, we call `App.render()`. This tells our application to redraw everything, taking the new filter into account.\n\n### 3. Applying the Filter and Updating UI\n\nThe magic truly happens in our `App.render()` function, which is responsible for drawing our To-Do list.\n\n```javascript\n// From: js/app.js (inside App.render())\n\nrender() {\n    // ... other rendering logic ...\n\n    // 1. Highlight the correct filter link (All, Active, Completed)\n    App.$.setActiveFilter(App.filter);\n\n    // 2. Filter todos from the TodoStore and display them\n    App.$.list.replaceChildren(...Todos.all(App.filter).map((todo) => App.createTodoItem(todo)));\n\n    // ... other rendering logic ...\n\n    // 3. Display the count of *active* items\n    App.$.displayCount(Todos.all(\"active\").length);\n}\n```\n\n**Explanation:**\n1.  `App.$.setActiveFilter(App.filter);` uses the current `App.filter` (e.g., `\"active\"`) to add a \"selected\" CSS class to the corresponding filter link in the UI. This visually highlights the active filter.\n2.  `Todos.all(App.filter)` is where the [TodoStore](02_todostore.md) does its job! Instead of just giving us *all* todos, we pass `App.filter` to it. The [TodoStore](02_todostore.md) then intelligently returns only the todos that match the filter (e.g., only \"active\" ones).\n3.  The result of `Todos.all(App.filter)` is then used to create and display the actual To-Do items on the screen.\n4.  Notice that `App.$.displayCount(Todos.all(\"active\").length);` *always* shows the count of `active` items, regardless of the current view, which is a common pattern in To-Do apps.\n\n### How `setActiveFilter` Works\n\nLet's quickly look at `App.$.setActiveFilter` which highlights the filter buttons:\n\n```javascript\n// From: js/app.js (inside App.$)\n\nsetActiveFilter(filter) {\n    document.querySelectorAll(`[data-todo=\"filters\"] a`).forEach((el) => {\n        if (el.matches(`[href=\"#/${filter}\"]`)) { // Check if link's href matches current filter\n            el.classList.add(\"selected\");\n        } else {\n            el.classList.remove(\"selected\");\n        }\n    });\n},\n```\n\n**Explanation:**\n*   It finds all `<a>` tags inside the filters section.\n*   For each link, it checks if its `href` attribute (e.g., `href=\"#/active\"`) matches the current `filter` (e.g., `active`).\n*   If it matches, it adds the `selected` class to highlight it.\n*   If it doesn't match, it removes the `selected` class to un-highlight it.\n\n## View Router in Action: A Step-by-Step Flow\n\nLet's visualize what happens when a user clicks the \"Active\" filter button:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Browser as Web Browser\n    participant AppCtrl as Application Controller\n    participant Helpers as DOM Helpers\n    participant TodoStore as TodoStore\n\n    User->Browser: Clicks \"Active\" filter link (e.g., <a href=\"#/active\">)\n    Browser->Browser: Updates URL hash to #/active\n    Browser->AppCtrl: Triggers 'hashchange' event (on window)\n    AppCtrl->AppCtrl: Event listener calls `getURLHash()`\n    AppCtrl->Helpers: Calls `getURLHash()`\n    Helpers-->AppCtrl: Returns \"active\" (from #/active)\n    AppCtrl->AppCtrl: Sets `App.filter = \"active\"`\n    AppCtrl->AppCtrl: Calls `App.render()`\n    AppCtrl->AppCtrl: Calls `App.$.setActiveFilter(\"active\")`\n    AppCtrl->AppCtrl: Highlights \"Active\" link in UI\n    AppCtrl->TodoStore: Calls `Todos.all(\"active\")`\n    TodoStore-->AppCtrl: Returns list of only active todo items\n    AppCtrl->AppCtrl: `createTodoItem()` for each active todo\n    AppCtrl->Browser: Updates the displayed list of todos (only active ones)\n```\n\nAs you can see, the `View Router` (represented by the `App.filter` and the `hashchange` listener within the [Application Controller](01_application_controller.md) and the `getURLHash` [DOM Helpers](05_dom_helpers.md)) acts as the glue that connects the URL state to what the user sees on the screen.\n\n## Conclusion\n\nThe `View Router` is a powerful concept that allows our application to display different subsets of data based on the URL hash. It makes our app feel more like a real website, where you can bookmark specific views or share links that lead to a filtered list of tasks. By combining `getURLHash` with the `hashchange` event and wisely using `App.filter` in our `App.render()` method, we can create a dynamic and user-friendly filtering experience."
    ]
  }
}